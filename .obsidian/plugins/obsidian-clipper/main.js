/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/obsidian-daily-notes-interface/dist/main.js
var require_main = __commonJS({
  "node_modules/obsidian-daily-notes-interface/dist/main.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var obsidian = require("obsidian");
    var DEFAULT_DAILY_NOTE_FORMAT = "YYYY-MM-DD";
    var DEFAULT_WEEKLY_NOTE_FORMAT = "gggg-[W]ww";
    var DEFAULT_MONTHLY_NOTE_FORMAT = "YYYY-MM";
    var DEFAULT_QUARTERLY_NOTE_FORMAT = "YYYY-[Q]Q";
    var DEFAULT_YEARLY_NOTE_FORMAT = "YYYY";
    function shouldUsePeriodicNotesSettings(periodicity) {
      var _a, _b;
      const periodicNotes = window.app.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b = (_a = periodicNotes.settings) == null ? void 0 : _a[periodicity]) == null ? void 0 : _b.enabled);
    }
    function getDailyNoteSettings() {
      var _a, _b, _c, _d;
      try {
        const { internalPlugins, plugins } = window.app;
        if (shouldUsePeriodicNotesSettings("daily")) {
          const { format: format3, folder: folder2, template: template2 } = ((_b = (_a = plugins.getPlugin("periodic-notes")) == null ? void 0 : _a.settings) == null ? void 0 : _b.daily) || {};
          return {
            format: format3 || DEFAULT_DAILY_NOTE_FORMAT,
            folder: (folder2 == null ? void 0 : folder2.trim()) || "",
            template: (template2 == null ? void 0 : template2.trim()) || ""
          };
        }
        const { folder, format: format2, template } = ((_d = (_c = internalPlugins.getPluginById("daily-notes")) == null ? void 0 : _c.instance) == null ? void 0 : _d.options) || {};
        return {
          format: format2 || DEFAULT_DAILY_NOTE_FORMAT,
          folder: (folder == null ? void 0 : folder.trim()) || "",
          template: (template == null ? void 0 : template.trim()) || ""
        };
      } catch (err) {
        console.info("No custom daily note settings found!", err);
      }
    }
    function getWeeklyNoteSettings() {
      var _a, _b, _c, _d, _e, _f, _g;
      try {
        const pluginManager = window.app.plugins;
        const calendarSettings = (_a = pluginManager.getPlugin("calendar")) == null ? void 0 : _a.options;
        const periodicNotesSettings = (_c = (_b = pluginManager.getPlugin("periodic-notes")) == null ? void 0 : _b.settings) == null ? void 0 : _c.weekly;
        if (shouldUsePeriodicNotesSettings("weekly")) {
          return {
            format: periodicNotesSettings.format || DEFAULT_WEEKLY_NOTE_FORMAT,
            folder: ((_d = periodicNotesSettings.folder) == null ? void 0 : _d.trim()) || "",
            template: ((_e = periodicNotesSettings.template) == null ? void 0 : _e.trim()) || ""
          };
        }
        const settings2 = calendarSettings || {};
        return {
          format: settings2.weeklyNoteFormat || DEFAULT_WEEKLY_NOTE_FORMAT,
          folder: ((_f = settings2.weeklyNoteFolder) == null ? void 0 : _f.trim()) || "",
          template: ((_g = settings2.weeklyNoteTemplate) == null ? void 0 : _g.trim()) || ""
        };
      } catch (err) {
        console.info("No custom weekly note settings found!", err);
      }
    }
    function getMonthlyNoteSettings() {
      var _a, _b, _c, _d;
      const pluginManager = window.app.plugins;
      try {
        const settings2 = shouldUsePeriodicNotesSettings("monthly") && ((_b = (_a = pluginManager.getPlugin("periodic-notes")) == null ? void 0 : _a.settings) == null ? void 0 : _b.monthly) || {};
        return {
          format: settings2.format || DEFAULT_MONTHLY_NOTE_FORMAT,
          folder: ((_c = settings2.folder) == null ? void 0 : _c.trim()) || "",
          template: ((_d = settings2.template) == null ? void 0 : _d.trim()) || ""
        };
      } catch (err) {
        console.info("No custom monthly note settings found!", err);
      }
    }
    function getQuarterlyNoteSettings() {
      var _a, _b, _c, _d;
      const pluginManager = window.app.plugins;
      try {
        const settings2 = shouldUsePeriodicNotesSettings("quarterly") && ((_b = (_a = pluginManager.getPlugin("periodic-notes")) == null ? void 0 : _a.settings) == null ? void 0 : _b.quarterly) || {};
        return {
          format: settings2.format || DEFAULT_QUARTERLY_NOTE_FORMAT,
          folder: ((_c = settings2.folder) == null ? void 0 : _c.trim()) || "",
          template: ((_d = settings2.template) == null ? void 0 : _d.trim()) || ""
        };
      } catch (err) {
        console.info("No custom quarterly note settings found!", err);
      }
    }
    function getYearlyNoteSettings() {
      var _a, _b, _c, _d;
      const pluginManager = window.app.plugins;
      try {
        const settings2 = shouldUsePeriodicNotesSettings("yearly") && ((_b = (_a = pluginManager.getPlugin("periodic-notes")) == null ? void 0 : _a.settings) == null ? void 0 : _b.yearly) || {};
        return {
          format: settings2.format || DEFAULT_YEARLY_NOTE_FORMAT,
          folder: ((_c = settings2.folder) == null ? void 0 : _c.trim()) || "",
          template: ((_d = settings2.template) == null ? void 0 : _d.trim()) || ""
        };
      } catch (err) {
        console.info("No custom yearly note settings found!", err);
      }
    }
    function join2(...partSegments) {
      let parts = [];
      for (let i = 0, l = partSegments.length; i < l; i++) {
        parts = parts.concat(partSegments[i].split("/"));
      }
      const newParts = [];
      for (let i = 0, l = parts.length; i < l; i++) {
        const part = parts[i];
        if (!part || part === ".")
          continue;
        else
          newParts.push(part);
      }
      if (parts[0] === "")
        newParts.unshift("");
      return newParts.join("/");
    }
    function basename(fullPath) {
      let base = fullPath.substring(fullPath.lastIndexOf("/") + 1);
      if (base.lastIndexOf(".") != -1)
        base = base.substring(0, base.lastIndexOf("."));
      return base;
    }
    async function ensureFolderExists(path) {
      const dirs = path.replace(/\\/g, "/").split("/");
      dirs.pop();
      if (dirs.length) {
        const dir = join2(...dirs);
        if (!window.app.vault.getAbstractFileByPath(dir)) {
          await window.app.vault.createFolder(dir);
        }
      }
    }
    async function getNotePath(directory, filename) {
      if (!filename.endsWith(".md")) {
        filename += ".md";
      }
      const path = obsidian.normalizePath(join2(directory, filename));
      await ensureFolderExists(path);
      return path;
    }
    async function getTemplateInfo(template) {
      const { metadataCache, vault } = window.app;
      const templatePath = obsidian.normalizePath(template);
      if (templatePath === "/") {
        return Promise.resolve(["", null]);
      }
      try {
        const templateFile = metadataCache.getFirstLinkpathDest(templatePath, "");
        const contents = await vault.cachedRead(templateFile);
        const IFoldInfo = window.app.foldManager.load(templateFile);
        return [contents, IFoldInfo];
      } catch (err) {
        console.error(`Failed to read the daily note template '${templatePath}'`, err);
        new obsidian.Notice("Failed to read the daily note template");
        return ["", null];
      }
    }
    function getDateUID(date, granularity = "day") {
      const ts = date.clone().startOf(granularity).format();
      return `${granularity}-${ts}`;
    }
    function removeEscapedCharacters(format2) {
      return format2.replace(/\[[^\]]*\]/g, "");
    }
    function isFormatAmbiguous(format2, granularity) {
      if (granularity === "week") {
        const cleanFormat = removeEscapedCharacters(format2);
        return /w{1,2}/i.test(cleanFormat) && (/M{1,4}/.test(cleanFormat) || /D{1,4}/.test(cleanFormat));
      }
      return false;
    }
    function getDateFromFile(file, granularity) {
      return getDateFromFilename(file.basename, granularity);
    }
    function getDateFromPath(path, granularity) {
      return getDateFromFilename(basename(path), granularity);
    }
    function getDateFromFilename(filename, granularity) {
      const getSettings = {
        day: getDailyNoteSettings,
        week: getWeeklyNoteSettings,
        month: getMonthlyNoteSettings,
        quarter: getQuarterlyNoteSettings,
        year: getYearlyNoteSettings
      };
      const format2 = getSettings[granularity]().format.split("/").pop();
      const noteDate = window.moment(filename, format2, true);
      if (!noteDate.isValid()) {
        return null;
      }
      if (isFormatAmbiguous(format2, granularity)) {
        if (granularity === "week") {
          const cleanFormat = removeEscapedCharacters(format2);
          if (/w{1,2}/i.test(cleanFormat)) {
            return window.moment(filename, format2.replace(/M{1,4}/g, "").replace(/D{1,4}/g, ""), false);
          }
        }
      }
      return noteDate;
    }
    var DailyNotesFolderMissingError = class extends Error {
    };
    async function createDailyNote2(date) {
      const app = window.app;
      const { vault } = app;
      const moment = window.moment;
      const { template, format: format2, folder } = getDailyNoteSettings();
      const [templateContents, IFoldInfo] = await getTemplateInfo(template);
      const filename = date.format(format2);
      const normalizedPath = await getNotePath(folder, filename);
      try {
        const createdFile = await vault.create(normalizedPath, templateContents.replace(/{{\s*date\s*}}/gi, filename).replace(/{{\s*time\s*}}/gi, moment().format("HH:mm")).replace(/{{\s*title\s*}}/gi, filename).replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
          const now2 = moment();
          const currentDate = date.clone().set({
            hour: now2.get("hour"),
            minute: now2.get("minute"),
            second: now2.get("second")
          });
          if (calc) {
            currentDate.add(parseInt(timeDelta, 10), unit);
          }
          if (momentFormat) {
            return currentDate.format(momentFormat.substring(1).trim());
          }
          return currentDate.format(format2);
        }).replace(/{{\s*yesterday\s*}}/gi, date.clone().subtract(1, "day").format(format2)).replace(/{{\s*tomorrow\s*}}/gi, date.clone().add(1, "d").format(format2)));
        app.foldManager.save(createdFile, IFoldInfo);
        return createdFile;
      } catch (err) {
        console.error(`Failed to create file: '${normalizedPath}'`, err);
        new obsidian.Notice("Unable to create new file.");
      }
    }
    function getDailyNote2(date, dailyNotes) {
      var _a;
      return (_a = dailyNotes[getDateUID(date, "day")]) != null ? _a : null;
    }
    function getAllDailyNotes2() {
      const { vault } = window.app;
      const { folder } = getDailyNoteSettings();
      const dailyNotesFolder = vault.getAbstractFileByPath(obsidian.normalizePath(folder));
      if (!dailyNotesFolder) {
        throw new DailyNotesFolderMissingError("Failed to find daily notes folder");
      }
      const dailyNotes = {};
      obsidian.Vault.recurseChildren(dailyNotesFolder, (note) => {
        if (note instanceof obsidian.TFile) {
          const date = getDateFromFile(note, "day");
          if (date) {
            const dateString = getDateUID(date, "day");
            dailyNotes[dateString] = note;
          }
        }
      });
      return dailyNotes;
    }
    var WeeklyNotesFolderMissingError = class extends Error {
    };
    function getDaysOfWeek() {
      const { moment } = window;
      let weekStart = moment.localeData()._week.dow;
      const daysOfWeek = [
        "sunday",
        "monday",
        "tuesday",
        "wednesday",
        "thursday",
        "friday",
        "saturday"
      ];
      while (weekStart) {
        daysOfWeek.push(daysOfWeek.shift());
        weekStart--;
      }
      return daysOfWeek;
    }
    function getDayOfWeekNumericalValue(dayOfWeekName) {
      return getDaysOfWeek().indexOf(dayOfWeekName.toLowerCase());
    }
    async function createWeeklyNote2(date) {
      const { vault } = window.app;
      const { template, format: format2, folder } = getWeeklyNoteSettings();
      const [templateContents, IFoldInfo] = await getTemplateInfo(template);
      const filename = date.format(format2);
      const normalizedPath = await getNotePath(folder, filename);
      try {
        const createdFile = await vault.create(normalizedPath, templateContents.replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
          const now2 = window.moment();
          const currentDate = date.clone().set({
            hour: now2.get("hour"),
            minute: now2.get("minute"),
            second: now2.get("second")
          });
          if (calc) {
            currentDate.add(parseInt(timeDelta, 10), unit);
          }
          if (momentFormat) {
            return currentDate.format(momentFormat.substring(1).trim());
          }
          return currentDate.format(format2);
        }).replace(/{{\s*title\s*}}/gi, filename).replace(/{{\s*time\s*}}/gi, window.moment().format("HH:mm")).replace(/{{\s*(sunday|monday|tuesday|wednesday|thursday|friday|saturday)\s*:(.*?)}}/gi, (_, dayOfWeek, momentFormat) => {
          const day = getDayOfWeekNumericalValue(dayOfWeek);
          return date.weekday(day).format(momentFormat.trim());
        }));
        window.app.foldManager.save(createdFile, IFoldInfo);
        return createdFile;
      } catch (err) {
        console.error(`Failed to create file: '${normalizedPath}'`, err);
        new obsidian.Notice("Unable to create new file.");
      }
    }
    function getWeeklyNote2(date, weeklyNotes) {
      var _a;
      return (_a = weeklyNotes[getDateUID(date, "week")]) != null ? _a : null;
    }
    function getAllWeeklyNotes2() {
      const weeklyNotes = {};
      if (!appHasWeeklyNotesPluginLoaded2()) {
        return weeklyNotes;
      }
      const { vault } = window.app;
      const { folder } = getWeeklyNoteSettings();
      const weeklyNotesFolder = vault.getAbstractFileByPath(obsidian.normalizePath(folder));
      if (!weeklyNotesFolder) {
        throw new WeeklyNotesFolderMissingError("Failed to find weekly notes folder");
      }
      obsidian.Vault.recurseChildren(weeklyNotesFolder, (note) => {
        if (note instanceof obsidian.TFile) {
          const date = getDateFromFile(note, "week");
          if (date) {
            const dateString = getDateUID(date, "week");
            weeklyNotes[dateString] = note;
          }
        }
      });
      return weeklyNotes;
    }
    var MonthlyNotesFolderMissingError = class extends Error {
    };
    async function createMonthlyNote(date) {
      const { vault } = window.app;
      const { template, format: format2, folder } = getMonthlyNoteSettings();
      const [templateContents, IFoldInfo] = await getTemplateInfo(template);
      const filename = date.format(format2);
      const normalizedPath = await getNotePath(folder, filename);
      try {
        const createdFile = await vault.create(normalizedPath, templateContents.replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
          const now2 = window.moment();
          const currentDate = date.clone().set({
            hour: now2.get("hour"),
            minute: now2.get("minute"),
            second: now2.get("second")
          });
          if (calc) {
            currentDate.add(parseInt(timeDelta, 10), unit);
          }
          if (momentFormat) {
            return currentDate.format(momentFormat.substring(1).trim());
          }
          return currentDate.format(format2);
        }).replace(/{{\s*date\s*}}/gi, filename).replace(/{{\s*time\s*}}/gi, window.moment().format("HH:mm")).replace(/{{\s*title\s*}}/gi, filename));
        window.app.foldManager.save(createdFile, IFoldInfo);
        return createdFile;
      } catch (err) {
        console.error(`Failed to create file: '${normalizedPath}'`, err);
        new obsidian.Notice("Unable to create new file.");
      }
    }
    function getMonthlyNote(date, monthlyNotes) {
      var _a;
      return (_a = monthlyNotes[getDateUID(date, "month")]) != null ? _a : null;
    }
    function getAllMonthlyNotes() {
      const monthlyNotes = {};
      if (!appHasMonthlyNotesPluginLoaded()) {
        return monthlyNotes;
      }
      const { vault } = window.app;
      const { folder } = getMonthlyNoteSettings();
      const monthlyNotesFolder = vault.getAbstractFileByPath(obsidian.normalizePath(folder));
      if (!monthlyNotesFolder) {
        throw new MonthlyNotesFolderMissingError("Failed to find monthly notes folder");
      }
      obsidian.Vault.recurseChildren(monthlyNotesFolder, (note) => {
        if (note instanceof obsidian.TFile) {
          const date = getDateFromFile(note, "month");
          if (date) {
            const dateString = getDateUID(date, "month");
            monthlyNotes[dateString] = note;
          }
        }
      });
      return monthlyNotes;
    }
    var QuarterlyNotesFolderMissingError = class extends Error {
    };
    async function createQuarterlyNote(date) {
      const { vault } = window.app;
      const { template, format: format2, folder } = getQuarterlyNoteSettings();
      const [templateContents, IFoldInfo] = await getTemplateInfo(template);
      const filename = date.format(format2);
      const normalizedPath = await getNotePath(folder, filename);
      try {
        const createdFile = await vault.create(normalizedPath, templateContents.replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
          const now2 = window.moment();
          const currentDate = date.clone().set({
            hour: now2.get("hour"),
            minute: now2.get("minute"),
            second: now2.get("second")
          });
          if (calc) {
            currentDate.add(parseInt(timeDelta, 10), unit);
          }
          if (momentFormat) {
            return currentDate.format(momentFormat.substring(1).trim());
          }
          return currentDate.format(format2);
        }).replace(/{{\s*date\s*}}/gi, filename).replace(/{{\s*time\s*}}/gi, window.moment().format("HH:mm")).replace(/{{\s*title\s*}}/gi, filename));
        window.app.foldManager.save(createdFile, IFoldInfo);
        return createdFile;
      } catch (err) {
        console.error(`Failed to create file: '${normalizedPath}'`, err);
        new obsidian.Notice("Unable to create new file.");
      }
    }
    function getQuarterlyNote(date, quarterly) {
      var _a;
      return (_a = quarterly[getDateUID(date, "quarter")]) != null ? _a : null;
    }
    function getAllQuarterlyNotes() {
      const quarterly = {};
      if (!appHasQuarterlyNotesPluginLoaded()) {
        return quarterly;
      }
      const { vault } = window.app;
      const { folder } = getQuarterlyNoteSettings();
      const quarterlyFolder = vault.getAbstractFileByPath(obsidian.normalizePath(folder));
      if (!quarterlyFolder) {
        throw new QuarterlyNotesFolderMissingError("Failed to find quarterly notes folder");
      }
      obsidian.Vault.recurseChildren(quarterlyFolder, (note) => {
        if (note instanceof obsidian.TFile) {
          const date = getDateFromFile(note, "quarter");
          if (date) {
            const dateString = getDateUID(date, "quarter");
            quarterly[dateString] = note;
          }
        }
      });
      return quarterly;
    }
    var YearlyNotesFolderMissingError = class extends Error {
    };
    async function createYearlyNote(date) {
      const { vault } = window.app;
      const { template, format: format2, folder } = getYearlyNoteSettings();
      const [templateContents, IFoldInfo] = await getTemplateInfo(template);
      const filename = date.format(format2);
      const normalizedPath = await getNotePath(folder, filename);
      try {
        const createdFile = await vault.create(normalizedPath, templateContents.replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
          const now2 = window.moment();
          const currentDate = date.clone().set({
            hour: now2.get("hour"),
            minute: now2.get("minute"),
            second: now2.get("second")
          });
          if (calc) {
            currentDate.add(parseInt(timeDelta, 10), unit);
          }
          if (momentFormat) {
            return currentDate.format(momentFormat.substring(1).trim());
          }
          return currentDate.format(format2);
        }).replace(/{{\s*date\s*}}/gi, filename).replace(/{{\s*time\s*}}/gi, window.moment().format("HH:mm")).replace(/{{\s*title\s*}}/gi, filename));
        window.app.foldManager.save(createdFile, IFoldInfo);
        return createdFile;
      } catch (err) {
        console.error(`Failed to create file: '${normalizedPath}'`, err);
        new obsidian.Notice("Unable to create new file.");
      }
    }
    function getYearlyNote(date, yearlyNotes) {
      var _a;
      return (_a = yearlyNotes[getDateUID(date, "year")]) != null ? _a : null;
    }
    function getAllYearlyNotes() {
      const yearlyNotes = {};
      if (!appHasYearlyNotesPluginLoaded()) {
        return yearlyNotes;
      }
      const { vault } = window.app;
      const { folder } = getYearlyNoteSettings();
      const yearlyNotesFolder = vault.getAbstractFileByPath(obsidian.normalizePath(folder));
      if (!yearlyNotesFolder) {
        throw new YearlyNotesFolderMissingError("Failed to find yearly notes folder");
      }
      obsidian.Vault.recurseChildren(yearlyNotesFolder, (note) => {
        if (note instanceof obsidian.TFile) {
          const date = getDateFromFile(note, "year");
          if (date) {
            const dateString = getDateUID(date, "year");
            yearlyNotes[dateString] = note;
          }
        }
      });
      return yearlyNotes;
    }
    function appHasDailyNotesPluginLoaded2() {
      var _a, _b;
      const { app } = window;
      const dailyNotesPlugin = app.internalPlugins.plugins["daily-notes"];
      if (dailyNotesPlugin && dailyNotesPlugin.enabled) {
        return true;
      }
      const periodicNotes = app.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b = (_a = periodicNotes.settings) == null ? void 0 : _a.daily) == null ? void 0 : _b.enabled);
    }
    function appHasWeeklyNotesPluginLoaded2() {
      var _a, _b;
      const { app } = window;
      if (app.plugins.getPlugin("calendar")) {
        return true;
      }
      const periodicNotes = app.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b = (_a = periodicNotes.settings) == null ? void 0 : _a.weekly) == null ? void 0 : _b.enabled);
    }
    function appHasMonthlyNotesPluginLoaded() {
      var _a, _b;
      const { app } = window;
      const periodicNotes = app.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b = (_a = periodicNotes.settings) == null ? void 0 : _a.monthly) == null ? void 0 : _b.enabled);
    }
    function appHasQuarterlyNotesPluginLoaded() {
      var _a, _b;
      const { app } = window;
      const periodicNotes = app.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b = (_a = periodicNotes.settings) == null ? void 0 : _a.quarterly) == null ? void 0 : _b.enabled);
    }
    function appHasYearlyNotesPluginLoaded() {
      var _a, _b;
      const { app } = window;
      const periodicNotes = app.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b = (_a = periodicNotes.settings) == null ? void 0 : _a.yearly) == null ? void 0 : _b.enabled);
    }
    function getPeriodicNoteSettings(granularity) {
      const getSettings = {
        day: getDailyNoteSettings,
        week: getWeeklyNoteSettings,
        month: getMonthlyNoteSettings,
        quarter: getQuarterlyNoteSettings,
        year: getYearlyNoteSettings
      }[granularity];
      return getSettings();
    }
    function createPeriodicNote(granularity, date) {
      const createFn = {
        day: createDailyNote2,
        month: createMonthlyNote,
        week: createWeeklyNote2
      };
      return createFn[granularity](date);
    }
    exports.DEFAULT_DAILY_NOTE_FORMAT = DEFAULT_DAILY_NOTE_FORMAT;
    exports.DEFAULT_MONTHLY_NOTE_FORMAT = DEFAULT_MONTHLY_NOTE_FORMAT;
    exports.DEFAULT_QUARTERLY_NOTE_FORMAT = DEFAULT_QUARTERLY_NOTE_FORMAT;
    exports.DEFAULT_WEEKLY_NOTE_FORMAT = DEFAULT_WEEKLY_NOTE_FORMAT;
    exports.DEFAULT_YEARLY_NOTE_FORMAT = DEFAULT_YEARLY_NOTE_FORMAT;
    exports.appHasDailyNotesPluginLoaded = appHasDailyNotesPluginLoaded2;
    exports.appHasMonthlyNotesPluginLoaded = appHasMonthlyNotesPluginLoaded;
    exports.appHasQuarterlyNotesPluginLoaded = appHasQuarterlyNotesPluginLoaded;
    exports.appHasWeeklyNotesPluginLoaded = appHasWeeklyNotesPluginLoaded2;
    exports.appHasYearlyNotesPluginLoaded = appHasYearlyNotesPluginLoaded;
    exports.createDailyNote = createDailyNote2;
    exports.createMonthlyNote = createMonthlyNote;
    exports.createPeriodicNote = createPeriodicNote;
    exports.createQuarterlyNote = createQuarterlyNote;
    exports.createWeeklyNote = createWeeklyNote2;
    exports.createYearlyNote = createYearlyNote;
    exports.getAllDailyNotes = getAllDailyNotes2;
    exports.getAllMonthlyNotes = getAllMonthlyNotes;
    exports.getAllQuarterlyNotes = getAllQuarterlyNotes;
    exports.getAllWeeklyNotes = getAllWeeklyNotes2;
    exports.getAllYearlyNotes = getAllYearlyNotes;
    exports.getDailyNote = getDailyNote2;
    exports.getDailyNoteSettings = getDailyNoteSettings;
    exports.getDateFromFile = getDateFromFile;
    exports.getDateFromPath = getDateFromPath;
    exports.getDateUID = getDateUID;
    exports.getMonthlyNote = getMonthlyNote;
    exports.getMonthlyNoteSettings = getMonthlyNoteSettings;
    exports.getPeriodicNoteSettings = getPeriodicNoteSettings;
    exports.getQuarterlyNote = getQuarterlyNote;
    exports.getQuarterlyNoteSettings = getQuarterlyNoteSettings;
    exports.getTemplateInfo = getTemplateInfo;
    exports.getWeeklyNote = getWeeklyNote2;
    exports.getWeeklyNoteSettings = getWeeklyNoteSettings;
    exports.getYearlyNote = getYearlyNote;
    exports.getYearlyNoteSettings = getYearlyNoteSettings;
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ObsidianClipperPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// node_modules/deepmerge-ts/dist/node/index.mjs
var actions = {
  defaultMerge: Symbol("deepmerge-ts: default merge"),
  skip: Symbol("deepmerge-ts: skip")
};
var actionsInto = {
  defaultMerge: actions.defaultMerge
};
function defaultMetaDataUpdater(previousMeta, metaMeta) {
  return metaMeta;
}
function getObjectType(object) {
  if (typeof object !== "object" || object === null) {
    return 0;
  }
  if (Array.isArray(object)) {
    return 2;
  }
  if (isRecord(object)) {
    return 1;
  }
  if (object instanceof Set) {
    return 3;
  }
  if (object instanceof Map) {
    return 4;
  }
  return 5;
}
function getKeys(objects) {
  const keys = /* @__PURE__ */ new Set();
  for (const object of objects) {
    for (const key of [
      ...Object.keys(object),
      ...Object.getOwnPropertySymbols(object)
    ]) {
      keys.add(key);
    }
  }
  return keys;
}
function objectHasProperty(object, property) {
  return typeof object === "object" && Object.prototype.propertyIsEnumerable.call(object, property);
}
function getIterableOfIterables(iterables) {
  return {
    *[Symbol.iterator]() {
      for (const iterable of iterables) {
        for (const value of iterable) {
          yield value;
        }
      }
    }
  };
}
var validRecordToStringValues = /* @__PURE__ */ new Set([
  "[object Object]",
  "[object Module]"
]);
function isRecord(value) {
  if (!validRecordToStringValues.has(Object.prototype.toString.call(value))) {
    return false;
  }
  const { constructor } = value;
  if (constructor === void 0) {
    return true;
  }
  const prototype = constructor.prototype;
  if (prototype === null || typeof prototype !== "object" || !validRecordToStringValues.has(Object.prototype.toString.call(prototype))) {
    return false;
  }
  if (!prototype.hasOwnProperty("isPrototypeOf")) {
    return false;
  }
  return true;
}
function mergeRecords$2(values, utils, meta) {
  const result = {};
  for (const key of getKeys(values)) {
    const propValues = [];
    for (const value of values) {
      if (objectHasProperty(value, key)) {
        propValues.push(value[key]);
      }
    }
    if (propValues.length === 0) {
      continue;
    }
    const updatedMeta = utils.metaDataUpdater(meta, {
      key,
      parents: values
    });
    const propertyResult = mergeUnknowns(propValues, utils, updatedMeta);
    if (propertyResult === actions.skip) {
      continue;
    }
    if (key === "__proto__") {
      Object.defineProperty(result, key, {
        value: propertyResult,
        configurable: true,
        enumerable: true,
        writable: true
      });
    } else {
      result[key] = propertyResult;
    }
  }
  return result;
}
function mergeArrays$2(values) {
  return values.flat();
}
function mergeSets$2(values) {
  return new Set(getIterableOfIterables(values));
}
function mergeMaps$2(values) {
  return new Map(getIterableOfIterables(values));
}
function mergeOthers$2(values) {
  return values[values.length - 1];
}
var defaultMergeFunctions = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  mergeRecords: mergeRecords$2,
  mergeArrays: mergeArrays$2,
  mergeSets: mergeSets$2,
  mergeMaps: mergeMaps$2,
  mergeOthers: mergeOthers$2
});
function deepmerge(...objects) {
  return deepmergeCustom({})(...objects);
}
function deepmergeCustom(options, rootMetaData) {
  const utils = getUtils(options, customizedDeepmerge);
  function customizedDeepmerge(...objects) {
    return mergeUnknowns(objects, utils, rootMetaData);
  }
  return customizedDeepmerge;
}
function getUtils(options, customizedDeepmerge) {
  var _a, _b;
  return {
    defaultMergeFunctions,
    mergeFunctions: {
      ...defaultMergeFunctions,
      ...Object.fromEntries(Object.entries(options).filter(([key, option]) => Object.prototype.hasOwnProperty.call(defaultMergeFunctions, key)).map(([key, option]) => option === false ? [key, mergeOthers$2] : [key, option]))
    },
    metaDataUpdater: (_a = options.metaDataUpdater) !== null && _a !== void 0 ? _a : defaultMetaDataUpdater,
    deepmerge: customizedDeepmerge,
    useImplicitDefaultMerging: (_b = options.enableImplicitDefaultMerging) !== null && _b !== void 0 ? _b : false,
    actions
  };
}
function mergeUnknowns(values, utils, meta) {
  if (values.length === 0) {
    return void 0;
  }
  if (values.length === 1) {
    return mergeOthers$1(values, utils, meta);
  }
  const type = getObjectType(values[0]);
  if (type !== 0 && type !== 5) {
    for (let m_index = 1; m_index < values.length; m_index++) {
      if (getObjectType(values[m_index]) === type) {
        continue;
      }
      return mergeOthers$1(values, utils, meta);
    }
  }
  switch (type) {
    case 1: {
      return mergeRecords$1(values, utils, meta);
    }
    case 2: {
      return mergeArrays$1(values, utils, meta);
    }
    case 3: {
      return mergeSets$1(values, utils, meta);
    }
    case 4: {
      return mergeMaps$1(values, utils, meta);
    }
    default: {
      return mergeOthers$1(values, utils, meta);
    }
  }
}
function mergeRecords$1(values, utils, meta) {
  const result = utils.mergeFunctions.mergeRecords(values, utils, meta);
  if (result === actions.defaultMerge || utils.useImplicitDefaultMerging && result === void 0 && utils.mergeFunctions.mergeRecords !== utils.defaultMergeFunctions.mergeRecords) {
    return utils.defaultMergeFunctions.mergeRecords(values, utils, meta);
  }
  return result;
}
function mergeArrays$1(values, utils, meta) {
  const result = utils.mergeFunctions.mergeArrays(values, utils, meta);
  if (result === actions.defaultMerge || utils.useImplicitDefaultMerging && result === void 0 && utils.mergeFunctions.mergeArrays !== utils.defaultMergeFunctions.mergeArrays) {
    return utils.defaultMergeFunctions.mergeArrays(values);
  }
  return result;
}
function mergeSets$1(values, utils, meta) {
  const result = utils.mergeFunctions.mergeSets(values, utils, meta);
  if (result === actions.defaultMerge || utils.useImplicitDefaultMerging && result === void 0 && utils.mergeFunctions.mergeSets !== utils.defaultMergeFunctions.mergeSets) {
    return utils.defaultMergeFunctions.mergeSets(values);
  }
  return result;
}
function mergeMaps$1(values, utils, meta) {
  const result = utils.mergeFunctions.mergeMaps(values, utils, meta);
  if (result === actions.defaultMerge || utils.useImplicitDefaultMerging && result === void 0 && utils.mergeFunctions.mergeMaps !== utils.defaultMergeFunctions.mergeMaps) {
    return utils.defaultMergeFunctions.mergeMaps(values);
  }
  return result;
}
function mergeOthers$1(values, utils, meta) {
  const result = utils.mergeFunctions.mergeOthers(values, utils, meta);
  if (result === actions.defaultMerge || utils.useImplicitDefaultMerging && result === void 0 && utils.mergeFunctions.mergeOthers !== utils.defaultMergeFunctions.mergeOthers) {
    return utils.defaultMergeFunctions.mergeOthers(values);
  }
  return result;
}

// src/settings/types.ts
var SectionPosition = {
  PREPEND: "prepend",
  APPEND: "append"
};
var DEFAULT_SETTINGS = {
  dailyNoteHeading: "",
  weeklyNoteHeading: "",
  tags: "",
  timestampFormat: "HH:mm",
  dailyOpenOnWrite: false,
  useDailyNote: true,
  dailyPosition: SectionPosition.APPEND,
  useWeeklyNote: false,
  weeklyPosition: SectionPosition.APPEND,
  weeklyOpenOnWrite: false,
  dailyEntryTemplateLocation: "",
  weeklyEntryTemplateLocation: "",
  topicEntryTemplateLocation: "",
  topicPosition: SectionPosition.APPEND,
  topicOpenOnWrite: false,
  markdownSettings: {
    h1: "#",
    h2: "##",
    h3: "###",
    h4: "####",
    h5: "#####",
    h6: "######"
  }
};

// src/utils.ts
var import_obsidian = require("obsidian");
async function getTemplateContents(app, templatePath) {
  const { metadataCache, vault } = app;
  const normalizedTemplatePath = (0, import_obsidian.normalizePath)(templatePath != null ? templatePath : "");
  if (templatePath === "/") {
    return Promise.resolve("");
  }
  let templateContents = "";
  try {
    const templateFile = metadataCache.getFirstLinkpathDest(normalizedTemplatePath, "");
    if (templateFile) {
      templateContents = await vault.cachedRead(templateFile);
    }
    return templateContents;
  } catch (err) {
    console.error(`Failed to read the clipper entry template '${normalizedTemplatePath}'`, err);
    new import_obsidian.Notice("Failed to read the Obsidian Clipper daily note entry template configured in Settings");
    throw Error("Template File Missing");
  }
}
function applyTemplateTransformations(title, url, tags, time, content = "", rawTemplateContents) {
  const templateContents = rawTemplateContents.replace(/{{\s*title\s*}}/gi, title).replace(/{{\s*url\s*}}/gi, url).replace(/{{\s*tags\s*}}/gi, tags).replace(/{{\s*content\s*}}/gi, content).replace(/{{\s*time\s*}}/gi, time);
  return templateContents;
}

// src/clippeddata.ts
var ClippedData = class {
  constructor(title, url, settings2, app, data = "") {
    this.title = title;
    this.url = url;
    this.title = title;
    this.url = url;
    if (data !== "") {
      this.data = data;
    }
    const tagJoins = [];
    settings2.tags.split(",").forEach((t) => {
      tagJoins.push(`#${t}`);
    });
    this.tags = tagJoins.join(" ");
    this.settings = settings2;
    this.app = app;
    this.timeStamp = window.moment().format(this.settings.timestampFormat);
  }
  async formattedEntry(template) {
    let formattedData = "";
    if (template && template != "") {
      const rawTemplateContents = await getTemplateContents(this.app, template);
      formattedData = applyTemplateTransformations(this.title, this.url, this.tags, this.timeStamp, this.data, rawTemplateContents);
    } else {
      if (!this.data) {
        formattedData = `- [ ] [${this.title}](${this.url}) ${this.tags}

---`;
      } else {
        formattedData = `- [ ] [${this.title}](${this.url}) ${this.tags}
${this.data}

---`;
      }
    }
    return formattedData;
  }
};

// src/bookmarkletgenerator.ts
var BookmarketlGenerator = class {
  constructor(vaultName, notePath = "") {
    this.vaultName = vaultName;
    this.notePath = notePath;
  }
  generateBookmarklet() {
    return `javascript:(function()%7B!function(n%2Ce)%7Bvar%20t%2Co%2Cc%2Ca%2Ci%3DencodeURIComponent(%22${this.vaultName}%22)%2Cd%3DencodeURIComponent(%22${this.notePath}%22)%3Bt%3Ddocument.URL%2Co%3Ddocument.title%2Cc%3Dfunction()%7Bvar%20n%3D%22%22%3Bif(void%200!%3D%3Dwindow.getSelection)%7Bvar%20e%3Dwindow.getSelection()%3Bif(e%26%26e.rangeCount)%7Bfor(var%20t%3Ddocument.createElement(%22div%22)%2Co%3D0%2Cc%3De.rangeCount%3Bo%3Cc%3B%2B%2Bo)t.appendChild(e.getRangeAt(o).cloneContents())%3Bn%3Dt.innerHTML%7D%7Dreturn%20n%7D()%2Ca%3D%22obsidian%3A%2F%2Fobsidian-clipper%3Fvault%3D%22.concat(i%2C%22%26notePath%3D%22).concat(d%2C%22%26url%3D%22).concat(encodeURIComponent(t)%2C%22%26title%3D%22).concat(encodeURIComponent(o)%2C%22%26format%3Dhtml%26highlightdata%3D%22).concat(encodeURIComponent(c))%2Cdocument.location.href%3Da%7D()%3B%7D)()`;
  }
};

// src/periodicnotes/dailyperiodicnoteentry.ts
var import_obsidian_daily_notes_interface = __toESM(require_main());

// src/periodicnotes/periodicnoteentry.ts
var import_obsidian4 = require("obsidian");

// src/abstracts/noteentry.ts
var import_obsidian3 = require("obsidian");

// src/periodicnotes/filewriter.ts
var import_obsidian2 = require("obsidian");

// src/utils/utility.ts
var Utility = class {
  static assertNotNull(value) {
    if (!value) {
      throw new Error("Value is null");
    }
  }
};

// src/periodicnotes/filewriter.ts
var FileWriter = class {
  constructor(app, openFileOnWrite) {
    this.app = app;
    this.openFileOnWrite = openFileOnWrite;
  }
  async write(file, clippedData, heading) {
    const fileData = await this.app.vault.read(file);
    const fileLines = fileData.split("\n");
    if (!heading) {
      const startLine = this.getEndOfFrontmatter(file);
      return this.writeAndOpenFile(file.path, this.positionDataWithNoHeader(fileData, clippedData, startLine));
    } else {
      let insertSection = {
        firstLine: 0,
        lastLine: 0
      };
      try {
        insertSection = this.getEndAndBeginningOfHeading(file, heading);
      } catch (e) {
        throw Error("Missing Expected Heading");
      }
      const preSectionContent = fileLines.slice(0, insertSection.firstLine);
      let targetSection = fileLines.slice(insertSection.firstLine, insertSection.lastLine);
      targetSection = this.positionDataWithHeader(targetSection, clippedData);
      let lines = [];
      if (insertSection.lastLine !== -1) {
        const postSectionContent = fileLines.slice(insertSection.lastLine);
        lines = [...preSectionContent, ...targetSection, ...postSectionContent];
      } else {
        lines = [...preSectionContent, ...targetSection];
      }
      return this.writeAndOpenFile(file.path, lines.join("\n"));
    }
  }
  async writeAndOpenFile(outputFileName, text2) {
    const file = this.app.vault.getAbstractFileByPath(outputFileName);
    if (file instanceof import_obsidian2.TFile) {
      await this.app.vault.modify(file, text2);
    } else {
      const parts = outputFileName.split("/");
      const dir = parts.slice(0, parts.length - 1).join("/");
      if (parts.length > 1 && !(this.app.vault.getAbstractFileByPath(dir) instanceof import_obsidian2.TFolder)) {
        await this.app.vault.createFolder(dir);
      }
      const base64regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
      if (base64regex.test(text2)) {
        await this.app.vault.createBinary(outputFileName, (0, import_obsidian2.base64ToArrayBuffer)(text2));
      } else {
        await this.app.vault.create(outputFileName, text2);
      }
    }
    if (this.openFileOnWrite) {
      let fileIsAlreadyOpened = false;
      this.app.workspace.iterateAllLeaves((leaf) => {
        var _a;
        if (((_a = leaf.view.file) == null ? void 0 : _a.path) === outputFileName) {
          fileIsAlreadyOpened = true;
          this.app.workspace.setActiveLeaf(leaf, { focus: true });
        }
      });
      if (!fileIsAlreadyOpened)
        await this.app.workspace.openLinkText(outputFileName, "", false);
    }
    return this.app.vault.getAbstractFileByPath(outputFileName);
  }
  getEndAndBeginningOfHeading(file, heading) {
    const cache = this.app.metadataCache.getFileCache(file);
    Utility.assertNotNull(cache);
    try {
      const cachedHeadings = cache.headings;
      Utility.assertNotNull(cachedHeadings);
      const foundHeadingIndex = cachedHeadings.findIndex((cachedHeading) => {
        return cachedHeading.heading === heading && cachedHeading.level === 1;
      });
      if (foundHeadingIndex) {
        const foundHeading = cachedHeadings[foundHeadingIndex];
        let nextHeading = null;
        for (let i = foundHeadingIndex + 1; i < (cachedHeadings == null ? void 0 : cachedHeadings.length); i++) {
          const cachedHeading = cachedHeadings[i];
          if (cachedHeading.level === 1) {
            nextHeading = cachedHeading;
            break;
          }
        }
        const prependLine = foundHeading.position.start.line;
        let appendLine = -1;
        if (nextHeading) {
          appendLine = nextHeading.position.start.line;
        }
        return { lastLine: appendLine, firstLine: prependLine };
      } else {
        throw Error("Heading not found");
      }
    } catch (e) {
      new import_obsidian2.Notice("Can't find heading");
      throw Error("Heading not found");
    }
  }
  getEndOfFrontmatter(file) {
    var _a;
    let endLine = 0;
    if (file) {
      const cache = this.app.metadataCache;
      if (cache) {
        const sections = (_a = cache.getFileCache(file)) == null ? void 0 : _a.sections;
        const frontmatter = sections == null ? void 0 : sections.find((item) => {
          return item.type = "yaml";
        });
        if (frontmatter) {
          endLine = frontmatter.position.end.line;
        }
      }
    }
    return endLine + 1;
  }
};

// src/periodicnotes/appendwriter.ts
var AppendWriter = class extends FileWriter {
  positionDataWithNoHeader(fileData, clippedData) {
    return fileData + "\n" + clippedData;
  }
  positionDataWithHeader(targetSection, clippedData) {
    targetSection.push(clippedData);
    return targetSection;
  }
};

// src/periodicnotes/prependwriter.ts
var PrependWriter = class extends FileWriter {
  positionDataWithNoHeader(fileData, clippedData, startLine = 0) {
    const fileLines = fileData.split("\n");
    const preSectionContent = fileLines.slice(0, startLine);
    const restOfContent = fileLines.slice(startLine);
    return [...preSectionContent, clippedData, ...restOfContent].join("\n");
  }
  positionDataWithHeader(targetSection, clippedData) {
    targetSection.splice(1, 0, clippedData);
    return targetSection;
  }
};

// src/abstracts/noteentry.ts
var NoteEntry = class {
  constructor(app, openFileOnWrite, sectionPosition, template) {
    this.app = app;
    this.openFileOnWrite = openFileOnWrite;
    this.sectionPosition = sectionPosition;
    this.template = template;
  }
  async handleWrite(noteFilePath, data, heading) {
    const file = this.app.vault.getAbstractFileByPath(noteFilePath);
    if (file instanceof import_obsidian3.TFile) {
      if (this.sectionPosition === SectionPosition.PREPEND) {
        new PrependWriter(this.app, this.openFileOnWrite).write(file, data, heading);
      } else {
        new AppendWriter(this.app, this.openFileOnWrite).write(file, data, heading);
      }
    } else {
      new import_obsidian3.Notice(`Obsidian Clipper couldn't find the note to ${this.sectionPosition} to`);
    }
  }
};

// src/periodicnotes/periodicnoteentry.ts
var PeriodicNoteEntry = class extends NoteEntry {
  constructor(app, openFileOnWrite, sectionPosition, template) {
    super(app, openFileOnWrite, sectionPosition, template);
    this.template = template;
  }
  async writeToPeriodicNote(noteEntry, heading) {
    if (!this.hasPeriodicNoteEnabled()) {
      new import_obsidian4.Notice(this.notice);
      return;
    }
    const note = await this.getNote();
    this.handleWrite(note.path, await noteEntry.formattedEntry(this.template), heading);
  }
  async getNote() {
    const now2 = globalThis.moment();
    const allNotes = this.getAllNotes();
    const periodicNote = this.getPeriodicNote(now2, allNotes);
    if (!periodicNote) {
      return await this.waitForNoteCreation(now2);
    }
    return periodicNote;
  }
};

// src/periodicnotes/dailyperiodicnoteentry.ts
var DailyPeriodicNoteEntry = class extends PeriodicNoteEntry {
  constructor(app, openFileOnWrite, sectionPosition, template) {
    super(app, openFileOnWrite, sectionPosition, template);
    this.notice = "To use a daily note with Obsidian Clipper the daily note needs to be enabled from the periodic-notes plugin";
  }
  getPeriodicNote(moment, allNotes) {
    return (0, import_obsidian_daily_notes_interface.getDailyNote)(moment, allNotes);
  }
  hasPeriodicNoteEnabled() {
    return (0, import_obsidian_daily_notes_interface.appHasDailyNotesPluginLoaded)();
  }
  async waitForNoteCreation(moment) {
    const dailyNote = await (0, import_obsidian_daily_notes_interface.createDailyNote)(moment);
    await new Promise((r) => setTimeout(r, 50));
    return dailyNote;
  }
  getAllNotes() {
    return (0, import_obsidian_daily_notes_interface.getAllDailyNotes)();
  }
};

// src/periodicnotes/weeklyperiodicnoteentry.ts
var import_obsidian_daily_notes_interface2 = __toESM(require_main());
var WeeklyPeriodicNoteEntry = class extends PeriodicNoteEntry {
  constructor(app, openFileOnWrite, sectionPosition, template) {
    super(app, openFileOnWrite, sectionPosition, template);
    this.notice = "To use a weekly note with Obsidian Clipper the weekly note needs to be enabled from the periodic-notes plugin";
  }
  getPeriodicNote(moment, allNotes) {
    return (0, import_obsidian_daily_notes_interface2.getWeeklyNote)(moment, allNotes);
  }
  hasPeriodicNoteEnabled() {
    return (0, import_obsidian_daily_notes_interface2.appHasWeeklyNotesPluginLoaded)();
  }
  async waitForNoteCreation(moment) {
    const weeklyNote = await (0, import_obsidian_daily_notes_interface2.createWeeklyNote)(moment);
    await new Promise((r) => setTimeout(r, 50));
    return weeklyNote;
  }
  getAllNotes() {
    return (0, import_obsidian_daily_notes_interface2.getAllWeeklyNotes)();
  }
};

// node_modules/svelte/internal/index.mjs
function noop() {
}
var identity = (x) => x;
function assign(tar, src) {
  for (const k in src)
    tar[k] = src[k];
  return tar;
}
function run(fn2) {
  return fn2();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    return noop;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function component_subscribe(component, store, callback) {
  component.$$.on_destroy.push(subscribe(store, callback));
}
function null_to_empty(value) {
  return value == null ? "" : value;
}
function set_store_value(store, ret, value) {
  store.set(value);
  return ret;
}
function action_destroyer(action_result) {
  return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
}
var is_client = typeof window !== "undefined";
var now = is_client ? () => window.performance.now() : () => Date.now();
var raf = is_client ? (cb) => requestAnimationFrame(cb) : noop;
var tasks = /* @__PURE__ */ new Set();
function run_tasks(now2) {
  tasks.forEach((task) => {
    if (!task.c(now2)) {
      tasks.delete(task);
      task.f();
    }
  });
  if (tasks.size !== 0)
    raf(run_tasks);
}
function loop(callback) {
  let task;
  if (tasks.size === 0)
    raf(run_tasks);
  return {
    promise: new Promise((fulfill) => {
      tasks.add(task = { c: callback, f: fulfill });
    }),
    abort() {
      tasks.delete(task);
    }
  };
}
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root2 = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root2 && root2.host) {
    return root2;
  }
  return node.ownerDocument;
}
function append_empty_stylesheet(node) {
  const style_element = element("style");
  append_stylesheet(get_root_for_style(node), style_element);
  return style_element.sheet;
}
function append_stylesheet(node, style) {
  append(node.head || node, style);
  return style.sheet;
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.wholeText !== data)
    text2.data = data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function select_option(select, value) {
  for (let i = 0; i < select.options.length; i += 1) {
    const option = select.options[i];
    if (option.__value === value) {
      option.selected = true;
      return;
    }
  }
  select.selectedIndex = -1;
}
function select_value(select) {
  const selected_option = select.querySelector(":checked") || select.options[0];
  return selected_option && selected_option.__value;
}
function toggle_class(element2, name, toggle) {
  element2.classList[toggle ? "add" : "remove"](name);
}
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
  const e = document.createEvent("CustomEvent");
  e.initCustomEvent(type, bubbles, cancelable, detail);
  return e;
}
function construct_svelte_component(component, props) {
  return new component(props);
}
var managed_styles = /* @__PURE__ */ new Map();
var active = 0;
function hash(str) {
  let hash4 = 5381;
  let i = str.length;
  while (i--)
    hash4 = (hash4 << 5) - hash4 ^ str.charCodeAt(i);
  return hash4 >>> 0;
}
function create_style_information(doc, node) {
  const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
  managed_styles.set(doc, info);
  return info;
}
function create_rule(node, a, b, duration, delay, ease, fn2, uid = 0) {
  const step = 16.666 / duration;
  let keyframes = "{\n";
  for (let p = 0; p <= 1; p += step) {
    const t = a + (b - a) * ease(p);
    keyframes += p * 100 + `%{${fn2(t, 1 - t)}}
`;
  }
  const rule = keyframes + `100% {${fn2(b, 1 - b)}}
}`;
  const name = `__svelte_${hash(rule)}_${uid}`;
  const doc = get_root_for_style(node);
  const { stylesheet, rules: rules2 } = managed_styles.get(doc) || create_style_information(doc, node);
  if (!rules2[name]) {
    rules2[name] = true;
    stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
  }
  const animation = node.style.animation || "";
  node.style.animation = `${animation ? `${animation}, ` : ""}${name} ${duration}ms linear ${delay}ms 1 both`;
  active += 1;
  return name;
}
function delete_rule(node, name) {
  const previous = (node.style.animation || "").split(", ");
  const next2 = previous.filter(name ? (anim) => anim.indexOf(name) < 0 : (anim) => anim.indexOf("__svelte") === -1);
  const deleted = previous.length - next2.length;
  if (deleted) {
    node.style.animation = next2.join(", ");
    active -= deleted;
    if (!active)
      clear_rules();
  }
}
function clear_rules() {
  raf(() => {
    if (active)
      return;
    managed_styles.forEach((info) => {
      const { ownerNode } = info.stylesheet;
      if (ownerNode)
        detach(ownerNode);
    });
    managed_styles.clear();
  });
}
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onDestroy(fn2) {
  get_current_component().$$.on_destroy.push(fn2);
}
function bubble(component, event) {
  const callbacks = component.$$.callbacks[event.type];
  if (callbacks) {
    callbacks.slice().forEach((fn2) => fn2.call(this, event));
  }
}
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn2) {
  render_callbacks.push(fn2);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
var promise;
function wait() {
  if (!promise) {
    promise = Promise.resolve();
    promise.then(() => {
      promise = null;
    });
  }
  return promise;
}
function dispatch(node, direction, kind) {
  node.dispatchEvent(custom_event(`${direction ? "intro" : "outro"}${kind}`));
}
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}
var null_transition = { duration: 0 };
function create_in_transition(node, fn2, params) {
  const options = { direction: "in" };
  let config = fn2(node, params, options);
  let running = false;
  let animation_name;
  let task;
  let uid = 0;
  function cleanup() {
    if (animation_name)
      delete_rule(node, animation_name);
  }
  function go() {
    const { delay = 0, duration = 300, easing = identity, tick: tick2 = noop, css } = config || null_transition;
    if (css)
      animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
    tick2(0, 1);
    const start_time = now() + delay;
    const end_time = start_time + duration;
    if (task)
      task.abort();
    running = true;
    add_render_callback(() => dispatch(node, true, "start"));
    task = loop((now2) => {
      if (running) {
        if (now2 >= end_time) {
          tick2(1, 0);
          dispatch(node, true, "end");
          cleanup();
          return running = false;
        }
        if (now2 >= start_time) {
          const t = easing((now2 - start_time) / duration);
          tick2(t, 1 - t);
        }
      }
      return running;
    });
  }
  let started = false;
  return {
    start() {
      if (started)
        return;
      started = true;
      delete_rule(node);
      if (is_function(config)) {
        config = config(options);
        wait().then(go);
      } else {
        go();
      }
    },
    invalidate() {
      started = false;
    },
    end() {
      if (running) {
        cleanup();
        running = false;
      }
    }
  };
}
function create_out_transition(node, fn2, params) {
  const options = { direction: "out" };
  let config = fn2(node, params, options);
  let running = true;
  let animation_name;
  const group = outros;
  group.r += 1;
  function go() {
    const { delay = 0, duration = 300, easing = identity, tick: tick2 = noop, css } = config || null_transition;
    if (css)
      animation_name = create_rule(node, 1, 0, duration, delay, easing, css);
    const start_time = now() + delay;
    const end_time = start_time + duration;
    add_render_callback(() => dispatch(node, false, "start"));
    loop((now2) => {
      if (running) {
        if (now2 >= end_time) {
          tick2(0, 1);
          dispatch(node, false, "end");
          if (!--group.r) {
            run_all(group.c);
          }
          return false;
        }
        if (now2 >= start_time) {
          const t = easing((now2 - start_time) / duration);
          tick2(1 - t, t);
        }
      }
      return running;
    });
  }
  if (is_function(config)) {
    wait().then(() => {
      config = config(options);
      go();
    });
  } else {
    go();
  }
  return {
    end(reset) {
      if (reset && config.tick) {
        config.tick(1, 0);
      }
      if (running) {
        if (animation_name)
          delete_rule(node, animation_name);
        running = false;
      }
    }
  };
}
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
function get_spread_update(levels, updates) {
  const update2 = {};
  const to_null_out = {};
  const accounted_for = { $$scope: 1 };
  let i = levels.length;
  while (i--) {
    const o = levels[i];
    const n = updates[i];
    if (n) {
      for (const key in o) {
        if (!(key in n))
          to_null_out[key] = 1;
      }
      for (const key in n) {
        if (!accounted_for[key]) {
          update2[key] = n[key];
          accounted_for[key] = 1;
        }
      }
      levels[i] = n;
    } else {
      for (const key in o) {
        accounted_for[key] = 1;
      }
    }
  }
  for (const key in to_null_out) {
    if (!(key in update2))
      update2[key] = void 0;
  }
  return update2;
}
function get_spread_object(spread_props) {
  return typeof spread_props === "object" && spread_props !== null ? spread_props : {};
}
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor, customElement) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  if (!customElement) {
    add_render_callback(() => {
      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
      if (component.$$.on_destroy) {
        component.$$.on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
  }
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance12, create_fragment13, not_equal, props, append_styles2, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance12 ? instance12(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment13 ? create_fragment13($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor, options.customElement);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: "open" });
    }
    connectedCallback() {
      const { on_mount } = this.$$;
      this.$$.on_disconnect = on_mount.map(run).filter(is_function);
      for (const key in this.$$.slotted) {
        this.appendChild(this.$$.slotted[key]);
      }
    }
    attributeChangedCallback(attr2, _oldValue, newValue) {
      this[attr2] = newValue;
    }
    disconnectedCallback() {
      run_all(this.$$.on_disconnect);
    }
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
    $on(type, callback) {
      if (!is_function(callback)) {
        return noop;
      }
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index = callbacks.indexOf(callback);
        if (index !== -1)
          callbacks.splice(index, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };
}
var SvelteComponent = class {
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  $set($$props) {
    if (this.$$set && !is_empty($$props)) {
      this.$$.skip_bound = true;
      this.$$set($$props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/svelte/easing/index.mjs
function cubicOut(t) {
  const f = t - 1;
  return f * f * f + 1;
}

// node_modules/svelte/transition/index.mjs
function slide(node, { delay = 0, duration = 400, easing = cubicOut } = {}) {
  const style = getComputedStyle(node);
  const opacity = +style.opacity;
  const height = parseFloat(style.height);
  const padding_top = parseFloat(style.paddingTop);
  const padding_bottom = parseFloat(style.paddingBottom);
  const margin_top = parseFloat(style.marginTop);
  const margin_bottom = parseFloat(style.marginBottom);
  const border_top_width = parseFloat(style.borderTopWidth);
  const border_bottom_width = parseFloat(style.borderBottomWidth);
  return {
    delay,
    duration,
    easing,
    css: (t) => `overflow: hidden;opacity: ${Math.min(t * 20, 1) * opacity};height: ${t * height}px;padding-top: ${t * padding_top}px;padding-bottom: ${t * padding_bottom}px;margin-top: ${t * margin_top}px;margin-bottom: ${t * margin_bottom}px;border-top-width: ${t * border_top_width}px;border-bottom-width: ${t * border_bottom_width}px;`
  };
}

// node_modules/@popperjs/core/lib/enums.js
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

// node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
function getNodeName(element2) {
  return element2 ? (element2.nodeName || "").toLowerCase() : null;
}

// node_modules/@popperjs/core/lib/dom-utils/getWindow.js
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}

// node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

// node_modules/@popperjs/core/lib/modifiers/applyStyles.js
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element2 = state.elements[name];
    if (!isHTMLElement(element2) || !getNodeName(element2)) {
      return;
    }
    Object.assign(element2.style, style);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element2.removeAttribute(name2);
      } else {
        element2.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element2 = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element2) || !getNodeName(element2)) {
        return;
      }
      Object.assign(element2.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element2.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles_default = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect,
  requires: ["computeStyles"]
};

// node_modules/@popperjs/core/lib/utils/getBasePlacement.js
function getBasePlacement(placement) {
  return placement.split("-")[0];
}

// node_modules/@popperjs/core/lib/utils/math.js
var max = Math.max;
var min = Math.min;
var round = Math.round;

// node_modules/@popperjs/core/lib/utils/userAgent.js
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}

// node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}

// node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
function getBoundingClientRect(element2, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element2.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element2)) {
    scaleX = element2.offsetWidth > 0 ? round(clientRect.width) / element2.offsetWidth || 1 : 1;
    scaleY = element2.offsetHeight > 0 ? round(clientRect.height) / element2.offsetHeight || 1 : 1;
  }
  var _ref = isElement(element2) ? getWindow(element2) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
function getLayoutRect(element2) {
  var clientRect = getBoundingClientRect(element2);
  var width = element2.offsetWidth;
  var height = element2.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element2.offsetLeft,
    y: element2.offsetTop,
    width,
    height
  };
}

// node_modules/@popperjs/core/lib/dom-utils/contains.js
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next2 = child;
    do {
      if (next2 && parent.isSameNode(next2)) {
        return true;
      }
      next2 = next2.parentNode || next2.host;
    } while (next2);
  }
  return false;
}

// node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
function getComputedStyle2(element2) {
  return getWindow(element2).getComputedStyle(element2);
}

// node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
function isTableElement(element2) {
  return ["table", "td", "th"].indexOf(getNodeName(element2)) >= 0;
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
function getDocumentElement(element2) {
  return ((isElement(element2) ? element2.ownerDocument : element2.document) || window.document).documentElement;
}

// node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
function getParentNode(element2) {
  if (getNodeName(element2) === "html") {
    return element2;
  }
  return element2.assignedSlot || element2.parentNode || (isShadowRoot(element2) ? element2.host : null) || getDocumentElement(element2);
}

// node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
function getTrueOffsetParent(element2) {
  if (!isHTMLElement(element2) || getComputedStyle2(element2).position === "fixed") {
    return null;
  }
  return element2.offsetParent;
}
function getContainingBlock(element2) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element2)) {
    var elementCss = getComputedStyle2(element2);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element2);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle2(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element2) {
  var window2 = getWindow(element2);
  var offsetParent = getTrueOffsetParent(element2);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element2) || window2;
}

// node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}

// node_modules/@popperjs/core/lib/utils/within.js
function within(min2, value, max2) {
  return max(min2, min(value, max2));
}
function withinMaxClamp(min2, value, max2) {
  var v = within(min2, value, max2);
  return v > max2 ? max2 : v;
}

// node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

// node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

// node_modules/@popperjs/core/lib/utils/expandToHashMap.js
function expandToHashMap(value, keys) {
  return keys.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

// node_modules/@popperjs/core/lib/modifiers/arrow.js
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect2(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (true) {
    if (!isHTMLElement(arrowElement)) {
      console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "));
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    if (true) {
      console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
    }
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow_default = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect2,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};

// node_modules/@popperjs/core/lib/utils/getVariation.js
function getVariation(placement) {
  return placement.split("-")[1];
}

// node_modules/@popperjs/core/lib/modifiers/computeStyles.js
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref) {
  var x = _ref.x, y = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle2(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  if (true) {
    var transitionProperty = getComputedStyle2(state.elements.popper).transitionProperty || "";
    if (adaptive && ["transform", "top", "right", "bottom", "left"].some(function(property) {
      return transitionProperty.indexOf(property) >= 0;
    })) {
      console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', "\n\n", 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", "\n\n", "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
    }
  }
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles_default = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};

// node_modules/@popperjs/core/lib/modifiers/eventListeners.js
var passive = {
  passive: true
};
function effect3(_ref) {
  var state = _ref.state, instance12 = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance12.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance12.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance12.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance12.update, passive);
    }
  };
}
var eventListeners_default = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect: effect3,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
var hash2 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash2[matched];
  });
}

// node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
var hash3 = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash3[matched];
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
function getWindowScrollBarX(element2) {
  return getBoundingClientRect(getDocumentElement(element2)).left + getWindowScroll(element2).scrollLeft;
}

// node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
function getViewportRect(element2, strategy) {
  var win = getWindow(element2);
  var html = getDocumentElement(element2);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x + getWindowScrollBarX(element2),
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
function getDocumentRect(element2) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element2);
  var winScroll = getWindowScroll(element2);
  var body = (_element$ownerDocumen = element2.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element2);
  var y = -winScroll.scrollTop;
  if (getComputedStyle2(body || html).direction === "rtl") {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
function isScrollParent(element2) {
  var _getComputedStyle = getComputedStyle2(element2), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

// node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}

// node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
function listScrollParents(element2, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element2);
  var isBody = scrollParent === ((_element$ownerDocumen = element2.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
}

// node_modules/@popperjs/core/lib/utils/rectToClientRect.js
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
function getInnerBoundingClientRect(element2, strategy) {
  var rect = getBoundingClientRect(element2, false, strategy === "fixed");
  rect.top = rect.top + element2.clientTop;
  rect.left = rect.left + element2.clientLeft;
  rect.bottom = rect.top + element2.clientHeight;
  rect.right = rect.left + element2.clientWidth;
  rect.width = element2.clientWidth;
  rect.height = element2.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element2, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element2, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element2)));
}
function getClippingParents(element2) {
  var clippingParents2 = listScrollParents(getParentNode(element2));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle2(element2).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element2) ? getOffsetParent(element2) : element2;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element2, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element2) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element2, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element2, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

// node_modules/@popperjs/core/lib/utils/computeOffsets.js
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element2 = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element2.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element2.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element2.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element2.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element2[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element2[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}

// node_modules/@popperjs/core/lib/utils/detectOverflow.js
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element2 = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element2) ? element2 : element2.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}

// node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements2.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements2;
    if (true) {
      console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" "));
    }
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b) {
    return overflows[a] - overflows[b];
  });
}

// node_modules/@popperjs/core/lib/modifiers/flip.js
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip_default = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};

// node_modules/@popperjs/core/lib/modifiers/hide.js
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide_default = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};

// node_modules/@popperjs/core/lib/modifiers/offset.js
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
}
var offset_default = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};

// node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets_default = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getAltAxis.js
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}

// node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min2 = offset2 + overflow[mainSide];
    var max2 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset2, tether ? max(max2, tetherMax) : max2);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
var preventOverflow_default = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};

// node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element2) {
  return {
    scrollLeft: element2.scrollLeft,
    scrollTop: element2.scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

// node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
function isElementScaled(element2) {
  var rect = element2.getBoundingClientRect();
  var scaleX = round(rect.width) / element2.offsetWidth || 1;
  var scaleY = round(rect.height) / element2.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// node_modules/@popperjs/core/lib/utils/orderModifiers.js
function order(modifiers) {
  var map = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

// node_modules/@popperjs/core/lib/utils/debounce.js
function debounce(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}

// node_modules/@popperjs/core/lib/utils/format.js
function format(str) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  return [].concat(args).reduce(function(p, c) {
    return p.replace(/%s/, c);
  }, str);
}

// node_modules/@popperjs/core/lib/utils/validateModifiers.js
var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
var VALID_PROPERTIES = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
function validateModifiers(modifiers) {
  modifiers.forEach(function(modifier) {
    [].concat(Object.keys(modifier), VALID_PROPERTIES).filter(function(value, index, self) {
      return self.indexOf(value) === index;
    }).forEach(function(key) {
      switch (key) {
        case "name":
          if (typeof modifier.name !== "string") {
            console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', '"' + String(modifier.name) + '"'));
          }
          break;
        case "enabled":
          if (typeof modifier.enabled !== "boolean") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', '"' + String(modifier.enabled) + '"'));
          }
          break;
        case "phase":
          if (modifierPhases.indexOf(modifier.phase) < 0) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(", "), '"' + String(modifier.phase) + '"'));
          }
          break;
        case "fn":
          if (typeof modifier.fn !== "function") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', '"' + String(modifier.fn) + '"'));
          }
          break;
        case "effect":
          if (modifier.effect != null && typeof modifier.effect !== "function") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', '"' + String(modifier.fn) + '"'));
          }
          break;
        case "requires":
          if (modifier.requires != null && !Array.isArray(modifier.requires)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', '"' + String(modifier.requires) + '"'));
          }
          break;
        case "requiresIfExists":
          if (!Array.isArray(modifier.requiresIfExists)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', '"' + String(modifier.requiresIfExists) + '"'));
          }
          break;
        case "options":
        case "data":
          break;
        default:
          console.error('PopperJS: an invalid property has been provided to the "' + modifier.name + '" modifier, valid properties are ' + VALID_PROPERTIES.map(function(s) {
            return '"' + s + '"';
          }).join(", ") + '; but "' + key + '" was provided.');
      }
      modifier.requires && modifier.requires.forEach(function(requirement) {
        if (modifiers.find(function(mod) {
          return mod.name === requirement;
        }) == null) {
          console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
        }
      });
    });
  });
}

// node_modules/@popperjs/core/lib/utils/uniqueBy.js
function uniqueBy(arr, fn2) {
  var identifiers = /* @__PURE__ */ new Set();
  return arr.filter(function(item) {
    var identifier = fn2(item);
    if (!identifiers.has(identifier)) {
      identifiers.add(identifier);
      return true;
    }
  });
}

// node_modules/@popperjs/core/lib/utils/mergeByName.js
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}

// node_modules/@popperjs/core/lib/createPopper.js
var INVALID_ELEMENT_ERROR = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.";
var INFINITE_LOOP_ERROR = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.";
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element2) {
    return !(element2 && typeof element2.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance12 = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        if (true) {
          var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function(_ref) {
            var name = _ref.name;
            return name;
          });
          validateModifiers(modifiers);
          if (getBasePlacement(state.options.placement) === auto) {
            var flipModifier = state.orderedModifiers.find(function(_ref2) {
              var name = _ref2.name;
              return name === "flip";
            });
            if (!flipModifier) {
              console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
            }
          }
          var _getComputedStyle = getComputedStyle2(popper2), marginTop = _getComputedStyle.marginTop, marginRight = _getComputedStyle.marginRight, marginBottom = _getComputedStyle.marginBottom, marginLeft = _getComputedStyle.marginLeft;
          if ([marginTop, marginRight, marginBottom, marginLeft].some(function(margin) {
            return parseFloat(margin);
          })) {
            console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
          }
        }
        runModifierEffects();
        return instance12.update();
      },
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          if (true) {
            console.error(INVALID_ELEMENT_ERROR);
          }
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        var __debug_loops__ = 0;
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (true) {
            __debug_loops__ += 1;
            if (__debug_loops__ > 100) {
              console.error(INFINITE_LOOP_ERROR);
              break;
            }
          }
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name,
              instance: instance12
            }) || state;
          }
        }
      },
      update: debounce(function() {
        return new Promise(function(resolve) {
          instance12.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      if (true) {
        console.error(INVALID_ELEMENT_ERROR);
      }
      return instance12;
    }
    instance12.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref3) {
        var name = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect4 = _ref3.effect;
        if (typeof effect4 === "function") {
          var cleanupFn = effect4({
            state,
            name,
            instance: instance12,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance12;
  };
}

// node_modules/@popperjs/core/lib/popper.js
var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});

// node_modules/svelte-popperjs/dist/index.es.js
function createPopperActions(initOptions) {
  let popperInstance = null;
  let referenceNode;
  let contentNode;
  let options = initOptions;
  const initPopper = () => {
    if (referenceNode !== void 0 && contentNode !== void 0) {
      popperInstance = createPopper(referenceNode, contentNode, options);
    }
  };
  const deinitPopper = () => {
    if (popperInstance !== null) {
      popperInstance.destroy();
      popperInstance = null;
    }
  };
  const referenceAction = (node) => {
    if ("subscribe" in node) {
      setupVirtualElementObserver(node);
      return {};
    } else {
      referenceNode = node;
      initPopper();
      return {
        destroy() {
          deinitPopper();
        }
      };
    }
  };
  const setupVirtualElementObserver = (node) => {
    const unsubscribe = node.subscribe(($node) => {
      if (referenceNode === void 0) {
        referenceNode = $node;
        initPopper();
      } else {
        Object.assign(referenceNode, $node);
        popperInstance == null ? void 0 : popperInstance.update();
      }
    });
    onDestroy(unsubscribe);
  };
  const contentAction = (node, contentOptions) => {
    contentNode = node;
    options = { ...initOptions, ...contentOptions };
    initPopper();
    return {
      update(newContentOptions) {
        options = { ...initOptions, ...newContentOptions };
        popperInstance == null ? void 0 : popperInstance.setOptions(options);
      },
      destroy() {
        deinitPopper();
      }
    };
  };
  return [referenceAction, contentAction, () => popperInstance];
}

// src/settings/components/Suggest.svelte
function add_css(target) {
  append_styles(target, "svelte-153zjst", ".search_input.svelte-153zjst{width:calc(100% - 20px)}.suggestion-container.svelte-153zjst{text-align:left}");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[18] = list[i];
  return child_ctx;
}
function create_if_block(ctx) {
  let div1;
  let div0;
  let popperContent_action;
  let mounted;
  let dispose;
  let each_value = ctx[3];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div0, "class", "suggestion");
      attr(div1, "class", "suggestion-container svelte-153zjst");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div0, null);
      }
      if (!mounted) {
        dispose = action_destroyer(popperContent_action = ctx[5].call(null, div1, ctx[6]));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 904) {
        each_value = ctx2[3];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div0, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block(ctx) {
  let div;
  let t0_value = ctx[18] + "";
  let t0;
  let t1;
  let mounted;
  let dispose;
  function click_handler() {
    return ctx[17](ctx[18]);
  }
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      attr(div, "class", "suggestion-item");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      if (!mounted) {
        dispose = [
          listen(div, "keydown", ctx[13]),
          listen(div, "focus", ctx[14]),
          listen(div, "blur", ctx[15]),
          listen(div, "click", click_handler),
          listen(div, "mouseover", ctx[8]),
          listen(div, "mouseout", ctx[9])
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 8 && t0_value !== (t0_value = ctx[18] + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment(ctx) {
  let div3;
  let div2;
  let div0;
  let t0;
  let t1;
  let div1;
  let t2;
  let t3;
  let div6;
  let div5;
  let div4;
  let input;
  let popperRef_action;
  let t4;
  let mounted;
  let dispose;
  let if_block = ctx[3].length > 0 && create_if_block(ctx);
  return {
    c() {
      div3 = element("div");
      div2 = element("div");
      div0 = element("div");
      t0 = text(ctx[1]);
      t1 = space();
      div1 = element("div");
      t2 = text(ctx[2]);
      t3 = space();
      div6 = element("div");
      div5 = element("div");
      div4 = element("div");
      input = element("input");
      t4 = space();
      if (if_block)
        if_block.c();
      attr(div0, "class", "setting-item-name");
      attr(div1, "class", "setting-item-description");
      attr(div2, "class", "setting-item-info");
      attr(div3, "class", "setting-item align-start");
      attr(input, "type", "text");
      attr(input, "spellcheck", "false");
      attr(input, "class", "search_input svelte-153zjst");
      attr(div4, "class", "search_input svelte-153zjst");
      attr(div5, "class", "setting-item-control");
      attr(div6, "class", "setting-item");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div2);
      append(div2, div0);
      append(div0, t0);
      append(div2, t1);
      append(div2, div1);
      append(div1, t2);
      insert(target, t3, anchor);
      insert(target, div6, anchor);
      append(div6, div5);
      append(div5, div4);
      append(div4, input);
      set_input_value(input, ctx[0]);
      append(div5, t4);
      if (if_block)
        if_block.m(div5, null);
      if (!mounted) {
        dispose = [
          action_destroyer(popperRef_action = ctx[4].call(null, input)),
          listen(input, "input", ctx[16]),
          listen(input, "input", ctx[10])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 2)
        set_data(t0, ctx2[1]);
      if (dirty & 4)
        set_data(t2, ctx2[2]);
      if (dirty & 1 && input.value !== ctx2[0]) {
        set_input_value(input, ctx2[0]);
      }
      if (ctx2[3].length > 0) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          if_block.m(div5, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div3);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(div6);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let { name } = $$props;
  let { description } = $$props;
  let { initialValue } = $$props;
  let { onChange } = $$props;
  let { dataProvider } = $$props;
  const [popperRef, popperContent] = createPopperActions({
    placement: "bottom-start",
    strategy: "fixed"
  });
  const extraOpts = {
    modifiers: [
      {
        name: "offset",
        options: { offset: [0, 5] }
      },
      {
        name: "sameWidth",
        enabled: true,
        fn: ({ state, instance: instance12 }) => {
          const targetWidth = `${state.rects.reference.width}px`;
          if (state.styles.popper.width === targetWidth) {
            return;
          }
          state.styles.popper.width = targetWidth;
          instance12.update();
        },
        phase: "beforeWrite",
        requires: ["computeStyles"]
      }
    ]
  };
  let templateOptions = [];
  const setInputVal = (templateOption) => {
    $$invalidate(3, templateOptions = []);
    $$invalidate(0, initialValue = templateOption);
    onChange(templateOption);
  };
  const handleMouseOver = (e) => {
    if (e && e.target) {
      const target = e.target;
      target.addClass("is-selected");
    }
  };
  const handleMouseOut = (e) => {
    if (e && e.target) {
      const target = e.target;
      target.removeClass("is-selected");
    }
  };
  const filterFiles = () => {
    let storageArr = [];
    if (initialValue) {
      dataProvider().forEach((file) => {
        if (file.path.toLowerCase().startsWith(initialValue.toLowerCase())) {
          storageArr = [...storageArr, file.path.toLowerCase()];
        }
      });
    }
    $$invalidate(3, templateOptions = storageArr);
  };
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_input_handler() {
    initialValue = this.value;
    $$invalidate(0, initialValue);
  }
  const click_handler = (templateOption) => setInputVal(templateOption);
  $$self.$$set = ($$props2) => {
    if ("name" in $$props2)
      $$invalidate(1, name = $$props2.name);
    if ("description" in $$props2)
      $$invalidate(2, description = $$props2.description);
    if ("initialValue" in $$props2)
      $$invalidate(0, initialValue = $$props2.initialValue);
    if ("onChange" in $$props2)
      $$invalidate(11, onChange = $$props2.onChange);
    if ("dataProvider" in $$props2)
      $$invalidate(12, dataProvider = $$props2.dataProvider);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $:
        if (!initialValue) {
          $$invalidate(3, templateOptions = []);
        }
    }
  };
  return [
    initialValue,
    name,
    description,
    templateOptions,
    popperRef,
    popperContent,
    extraOpts,
    setInputVal,
    handleMouseOver,
    handleMouseOut,
    filterFiles,
    onChange,
    dataProvider,
    keydown_handler,
    focus_handler,
    blur_handler,
    input_input_handler,
    click_handler
  ];
}
var Suggest = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, {
      name: 1,
      description: 2,
      initialValue: 0,
      onChange: 11,
      dataProvider: 12
    }, add_css);
  }
};
var Suggest_default = Suggest;

// node_modules/svelte/store/index.mjs
var subscriber_queue = [];
function writable(value, start2 = noop) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn2) {
    set(fn2(value));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start2(set) || noop;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe2 };
}

// src/settings/settingsstore.ts
var settings;
function init2(plugin) {
  if (settings) {
    return;
  }
  const { subscribe: subscribe2, set, update: update2 } = writable(plugin.settings);
  settings = {
    subscribe: subscribe2,
    update: update2,
    set: (value) => {
      set(value);
      plugin.saveSettings();
    }
  };
}

// src/settings/DailySettingsGroup.svelte
function create_if_block2(ctx) {
  let div15;
  let div4;
  let div2;
  let t3;
  let div3;
  let input;
  let t4;
  let div9;
  let div7;
  let t8;
  let div8;
  let select0;
  let option0;
  let option1;
  let t11;
  let div14;
  let div12;
  let t15;
  let div13;
  let select1;
  let option2;
  let option2_value_value;
  let option3;
  let option3_value_value;
  let t18;
  let suggest;
  let div15_intro;
  let div15_outro;
  let current;
  let mounted;
  let dispose;
  suggest = new Suggest_default({
    props: {
      name: "Clipped Entry Template - Daily",
      description: "Choose the file to use as a template for the clipped entry in the daily \n			periodic note",
      initialValue: ctx[1].dailyEntryTemplateLocation,
      dataProvider: ctx[7],
      onChange: ctx[2]
    }
  });
  return {
    c() {
      div15 = element("div");
      div4 = element("div");
      div2 = element("div");
      div2.innerHTML = `<div class="setting-item-name">Daily Note Header</div> 
					<div class="setting-item-description">What header should highlight data be prepended under in your daily
						note?</div>`;
      t3 = space();
      div3 = element("div");
      input = element("input");
      t4 = space();
      div9 = element("div");
      div7 = element("div");
      div7.innerHTML = `<div class="setting-item-name">Daily Note Position</div> 
					<div class="setting-item-description">Would you like to prepend clippings to the top of the section or
						append them to the bottom of the section?</div>`;
      t8 = space();
      div8 = element("div");
      select0 = element("select");
      option0 = element("option");
      option0.textContent = "prepend";
      option1 = element("option");
      option1.textContent = "append";
      t11 = space();
      div14 = element("div");
      div12 = element("div");
      div12.innerHTML = `<div class="setting-item-name">Open File After Adding Clipping - Daily?</div> 
					<div class="setting-item-description">Would you like to open the daily note after adding the clipping?</div>`;
      t15 = space();
      div13 = element("div");
      select1 = element("select");
      option2 = element("option");
      option2.textContent = "Yes";
      option3 = element("option");
      option3.textContent = "No";
      t18 = space();
      create_component(suggest.$$.fragment);
      attr(div2, "class", "setting-item-info");
      attr(input, "type", "text");
      attr(input, "spellcheck", "false");
      attr(input, "placeholder", "");
      attr(div3, "class", "setting-item-control");
      attr(div4, "class", "setting-item");
      attr(div7, "class", "setting-item-info");
      option0.__value = "prepend";
      option0.value = option0.__value;
      option1.__value = "append";
      option1.value = option1.__value;
      attr(select0, "class", "dropdown");
      if (ctx[1].dailyPosition === void 0)
        add_render_callback(() => ctx[5].call(select0));
      attr(div8, "class", "setting-item-control");
      attr(div9, "class", "setting-item");
      attr(div12, "class", "setting-item-info");
      option2.__value = option2_value_value = true;
      option2.value = option2.__value;
      option3.__value = option3_value_value = false;
      option3.value = option3.__value;
      attr(select1, "class", "dropdown");
      if (ctx[1].dailyOpenOnWrite === void 0)
        add_render_callback(() => ctx[6].call(select1));
      attr(div13, "class", "setting-item-control");
      attr(div14, "class", "setting-item");
    },
    m(target, anchor) {
      insert(target, div15, anchor);
      append(div15, div4);
      append(div4, div2);
      append(div4, t3);
      append(div4, div3);
      append(div3, input);
      set_input_value(input, ctx[1].dailyNoteHeading);
      append(div15, t4);
      append(div15, div9);
      append(div9, div7);
      append(div9, t8);
      append(div9, div8);
      append(div8, select0);
      append(select0, option0);
      append(select0, option1);
      select_option(select0, ctx[1].dailyPosition);
      append(div15, t11);
      append(div15, div14);
      append(div14, div12);
      append(div14, t15);
      append(div14, div13);
      append(div13, select1);
      append(select1, option2);
      append(select1, option3);
      select_option(select1, ctx[1].dailyOpenOnWrite);
      append(div15, t18);
      mount_component(suggest, div15, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input, "input", ctx[4]),
          listen(select0, "change", ctx[5]),
          listen(select1, "change", ctx[6])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2 && input.value !== ctx2[1].dailyNoteHeading) {
        set_input_value(input, ctx2[1].dailyNoteHeading);
      }
      if (dirty & 2) {
        select_option(select0, ctx2[1].dailyPosition);
      }
      if (dirty & 2) {
        select_option(select1, ctx2[1].dailyOpenOnWrite);
      }
      const suggest_changes = {};
      if (dirty & 2)
        suggest_changes.initialValue = ctx2[1].dailyEntryTemplateLocation;
      if (dirty & 1)
        suggest_changes.dataProvider = ctx2[7];
      suggest.$set(suggest_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(suggest.$$.fragment, local);
      if (local) {
        add_render_callback(() => {
          if (div15_outro)
            div15_outro.end(1);
          div15_intro = create_in_transition(div15, slide, { duration: 300 });
          div15_intro.start();
        });
      }
      current = true;
    },
    o(local) {
      transition_out(suggest.$$.fragment, local);
      if (div15_intro)
        div15_intro.invalidate();
      if (local) {
        div15_outro = create_out_transition(div15, slide, { duration: 300 });
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div15);
      destroy_component(suggest);
      if (detaching && div15_outro)
        div15_outro.end();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment2(ctx) {
  let div3;
  let div2;
  let div0;
  let t1;
  let div1;
  let label;
  let input;
  let t2;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[1].useDailyNote && create_if_block2(ctx);
  return {
    c() {
      div3 = element("div");
      div2 = element("div");
      div0 = element("div");
      div0.innerHTML = `<h1 class="setting-item-name">Daily Note Entry</h1>`;
      t1 = space();
      div1 = element("div");
      label = element("label");
      input = element("input");
      t2 = space();
      if (if_block)
        if_block.c();
      attr(div0, "class", "setting-item-info");
      attr(input, "type", "checkbox");
      attr(label, "class", "checkbox-container");
      toggle_class(label, "is-enabled", ctx[1].useDailyNote);
      attr(div1, "class", "setting-item-control");
      attr(div2, "class", "setting-item mod-toggle");
      attr(div3, "class", "clp_section_margin");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div2);
      append(div2, div0);
      append(div2, t1);
      append(div2, div1);
      append(div1, label);
      append(label, input);
      input.checked = ctx[1].useDailyNote;
      append(div3, t2);
      if (if_block)
        if_block.m(div3, null);
      current = true;
      if (!mounted) {
        dispose = listen(input, "change", ctx[3]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 2) {
        input.checked = ctx2[1].useDailyNote;
      }
      if (!current || dirty & 2) {
        toggle_class(label, "is-enabled", ctx2[1].useDailyNote);
      }
      if (ctx2[1].useDailyNote) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div3, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let $settings;
  component_subscribe($$self, settings, ($$value) => $$invalidate(1, $settings = $$value));
  let { app } = $$props;
  const onChange = (entry) => {
    set_store_value(settings, $settings.dailyEntryTemplateLocation = entry, $settings);
  };
  function input_change_handler() {
    $settings.useDailyNote = this.checked;
    settings.set($settings);
  }
  function input_input_handler() {
    $settings.dailyNoteHeading = this.value;
    settings.set($settings);
  }
  function select0_change_handler() {
    $settings.dailyPosition = select_value(this);
    settings.set($settings);
  }
  function select1_change_handler() {
    $settings.dailyOpenOnWrite = select_value(this);
    settings.set($settings);
  }
  const func = () => app.vault.getMarkdownFiles();
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
  };
  return [
    app,
    $settings,
    onChange,
    input_change_handler,
    input_input_handler,
    select0_change_handler,
    select1_change_handler,
    func
  ];
}
var DailySettingsGroup = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment2, safe_not_equal, { app: 0 });
  }
};
var DailySettingsGroup_default = DailySettingsGroup;

// src/settings/WeeklySettingsGroup.svelte
function create_if_block3(ctx) {
  let div15;
  let div4;
  let div2;
  let t3;
  let div3;
  let input;
  let t4;
  let div9;
  let div7;
  let t8;
  let div8;
  let select0;
  let option0;
  let option1;
  let t11;
  let div14;
  let div12;
  let t15;
  let div13;
  let select1;
  let option2;
  let option2_value_value;
  let option3;
  let option3_value_value;
  let t18;
  let suggest;
  let div15_intro;
  let div15_outro;
  let current;
  let mounted;
  let dispose;
  suggest = new Suggest_default({
    props: {
      name: "Clipped Entry Template - Weekly",
      description: "Choose the file to use as a template for the clipped entry in the weekly\n			periodic note",
      initialValue: ctx[1].weeklyEntryTemplateLocation,
      dataProvider: ctx[7],
      onChange: ctx[2]
    }
  });
  return {
    c() {
      div15 = element("div");
      div4 = element("div");
      div2 = element("div");
      div2.innerHTML = `<div class="setting-item-name">Weekly Note Header</div> 
					<div class="setting-item-description">What header should highlight data be prepended/appended under in
						your daily note?</div>`;
      t3 = space();
      div3 = element("div");
      input = element("input");
      t4 = space();
      div9 = element("div");
      div7 = element("div");
      div7.innerHTML = `<div class="setting-item-name">Weekly Note Position</div> 
					<div class="setting-item-description">Would you like to prepend clippings to the top of the section or
						append them to the bottom of the section?</div>`;
      t8 = space();
      div8 = element("div");
      select0 = element("select");
      option0 = element("option");
      option0.textContent = "prepend";
      option1 = element("option");
      option1.textContent = "append";
      t11 = space();
      div14 = element("div");
      div12 = element("div");
      div12.innerHTML = `<div class="setting-item-name">Open File After Adding Clipping - Weekly?</div> 
					<div class="setting-item-description">Would you like to open the weekly note after adding the clipping?</div>`;
      t15 = space();
      div13 = element("div");
      select1 = element("select");
      option2 = element("option");
      option2.textContent = "Yes";
      option3 = element("option");
      option3.textContent = "No";
      t18 = space();
      create_component(suggest.$$.fragment);
      attr(div2, "class", "setting-item-info");
      attr(input, "type", "text");
      attr(input, "spellcheck", "false");
      attr(input, "placeholder", "");
      attr(div3, "class", "setting-item-control");
      attr(div4, "class", "setting-item");
      attr(div7, "class", "setting-item-info");
      option0.__value = "prepend";
      option0.value = option0.__value;
      option1.__value = "append";
      option1.value = option1.__value;
      attr(select0, "class", "dropdown");
      if (ctx[1].weeklyPosition === void 0)
        add_render_callback(() => ctx[5].call(select0));
      attr(div8, "class", "setting-item-control");
      attr(div9, "class", "setting-item");
      attr(div12, "class", "setting-item-info");
      option2.__value = option2_value_value = true;
      option2.value = option2.__value;
      option3.__value = option3_value_value = false;
      option3.value = option3.__value;
      attr(select1, "class", "dropdown");
      if (ctx[1].weeklyOpenOnWrite === void 0)
        add_render_callback(() => ctx[6].call(select1));
      attr(div13, "class", "setting-item-control");
      attr(div14, "class", "setting-item");
    },
    m(target, anchor) {
      insert(target, div15, anchor);
      append(div15, div4);
      append(div4, div2);
      append(div4, t3);
      append(div4, div3);
      append(div3, input);
      set_input_value(input, ctx[1].weeklyNoteHeading);
      append(div15, t4);
      append(div15, div9);
      append(div9, div7);
      append(div9, t8);
      append(div9, div8);
      append(div8, select0);
      append(select0, option0);
      append(select0, option1);
      select_option(select0, ctx[1].weeklyPosition);
      append(div15, t11);
      append(div15, div14);
      append(div14, div12);
      append(div14, t15);
      append(div14, div13);
      append(div13, select1);
      append(select1, option2);
      append(select1, option3);
      select_option(select1, ctx[1].weeklyOpenOnWrite);
      append(div15, t18);
      mount_component(suggest, div15, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input, "input", ctx[4]),
          listen(select0, "change", ctx[5]),
          listen(select1, "change", ctx[6])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2 && input.value !== ctx2[1].weeklyNoteHeading) {
        set_input_value(input, ctx2[1].weeklyNoteHeading);
      }
      if (dirty & 2) {
        select_option(select0, ctx2[1].weeklyPosition);
      }
      if (dirty & 2) {
        select_option(select1, ctx2[1].weeklyOpenOnWrite);
      }
      const suggest_changes = {};
      if (dirty & 2)
        suggest_changes.initialValue = ctx2[1].weeklyEntryTemplateLocation;
      if (dirty & 1)
        suggest_changes.dataProvider = ctx2[7];
      suggest.$set(suggest_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(suggest.$$.fragment, local);
      if (local) {
        add_render_callback(() => {
          if (div15_outro)
            div15_outro.end(1);
          div15_intro = create_in_transition(div15, slide, { duration: 300 });
          div15_intro.start();
        });
      }
      current = true;
    },
    o(local) {
      transition_out(suggest.$$.fragment, local);
      if (div15_intro)
        div15_intro.invalidate();
      if (local) {
        div15_outro = create_out_transition(div15, slide, { duration: 300 });
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div15);
      destroy_component(suggest);
      if (detaching && div15_outro)
        div15_outro.end();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment3(ctx) {
  let div3;
  let div2;
  let div0;
  let t1;
  let div1;
  let label;
  let input;
  let t2;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[1].useWeeklyNote && create_if_block3(ctx);
  return {
    c() {
      div3 = element("div");
      div2 = element("div");
      div0 = element("div");
      div0.innerHTML = `<h1 class="setting-item-name">Weekly Note Entry</h1>`;
      t1 = space();
      div1 = element("div");
      label = element("label");
      input = element("input");
      t2 = space();
      if (if_block)
        if_block.c();
      attr(div0, "class", "setting-item-info");
      attr(input, "type", "checkbox");
      attr(label, "class", "checkbox-container");
      toggle_class(label, "is-enabled", ctx[1].useWeeklyNote);
      attr(div1, "class", "setting-item-control");
      attr(div2, "class", "setting-item mod-toggle");
      attr(div3, "class", "clp_section_margin");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div2);
      append(div2, div0);
      append(div2, t1);
      append(div2, div1);
      append(div1, label);
      append(label, input);
      input.checked = ctx[1].useWeeklyNote;
      append(div3, t2);
      if (if_block)
        if_block.m(div3, null);
      current = true;
      if (!mounted) {
        dispose = listen(input, "change", ctx[3]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 2) {
        input.checked = ctx2[1].useWeeklyNote;
      }
      if (!current || dirty & 2) {
        toggle_class(label, "is-enabled", ctx2[1].useWeeklyNote);
      }
      if (ctx2[1].useWeeklyNote) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div3, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function instance3($$self, $$props, $$invalidate) {
  let $settings;
  component_subscribe($$self, settings, ($$value) => $$invalidate(1, $settings = $$value));
  let { app } = $$props;
  const onChange = (entry) => set_store_value(settings, $settings.weeklyEntryTemplateLocation = entry, $settings);
  function input_change_handler() {
    $settings.useWeeklyNote = this.checked;
    settings.set($settings);
  }
  function input_input_handler() {
    $settings.weeklyNoteHeading = this.value;
    settings.set($settings);
  }
  function select0_change_handler() {
    $settings.weeklyPosition = select_value(this);
    settings.set($settings);
  }
  function select1_change_handler() {
    $settings.weeklyOpenOnWrite = select_value(this);
    settings.set($settings);
  }
  const func = () => app.vault.getMarkdownFiles();
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
  };
  return [
    app,
    $settings,
    onChange,
    input_change_handler,
    input_input_handler,
    select0_change_handler,
    select1_change_handler,
    func
  ];
}
var WeeklySettingsGroup = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance3, create_fragment3, safe_not_equal, { app: 0 });
  }
};
var WeeklySettingsGroup_default = WeeklySettingsGroup;

// src/settings/CommonSettingsGroup.svelte
function create_fragment4(ctx) {
  let div11;
  let h1;
  let t1;
  let div4;
  let div2;
  let t5;
  let div3;
  let input0;
  let t6;
  let div10;
  let div8;
  let t12;
  let div9;
  let input1;
  let mounted;
  let dispose;
  return {
    c() {
      div11 = element("div");
      h1 = element("h1");
      h1.textContent = "Common Settings";
      t1 = space();
      div4 = element("div");
      div2 = element("div");
      div2.innerHTML = `<div class="setting-item-name">Tags</div> 
			<div class="setting-item-description">What tags would you like added to the captured highlights?</div>`;
      t5 = space();
      div3 = element("div");
      input0 = element("input");
      t6 = space();
      div10 = element("div");
      div8 = element("div");
      div8.innerHTML = `<div class="setting-item-name">Date Time Format</div> 
			<div class="setting-item-description"><div>Format you would like to use for the {{ time }}
					template in clippings. See</div> 
				<a href="https://momentjs.com/docs/#/displaying/format/">format reference</a></div>`;
      t12 = space();
      div9 = element("div");
      input1 = element("input");
      attr(div2, "class", "setting-item-info");
      attr(input0, "type", "text");
      attr(input0, "spellcheck", "false");
      attr(input0, "placeholder", "tags,seperated,by,commas");
      attr(div3, "class", "setting-item-control");
      attr(div4, "class", "setting-item");
      attr(div8, "class", "setting-item-info");
      attr(input1, "type", "text");
      attr(input1, "spellcheck", "false");
      attr(input1, "placeholder", "HH:mm");
      attr(div9, "class", "setting-item-control");
      attr(div10, "class", "setting-item");
      attr(div11, "class", "clp_section_margin");
    },
    m(target, anchor) {
      insert(target, div11, anchor);
      append(div11, h1);
      append(div11, t1);
      append(div11, div4);
      append(div4, div2);
      append(div4, t5);
      append(div4, div3);
      append(div3, input0);
      set_input_value(input0, ctx[0].tags);
      append(div11, t6);
      append(div11, div10);
      append(div10, div8);
      append(div10, t12);
      append(div10, div9);
      append(div9, input1);
      set_input_value(input1, ctx[0].timestampFormat);
      if (!mounted) {
        dispose = [
          listen(input0, "input", ctx[1]),
          listen(input1, "input", ctx[2])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 1 && input0.value !== ctx2[0].tags) {
        set_input_value(input0, ctx2[0].tags);
      }
      if (dirty & 1 && input1.value !== ctx2[0].timestampFormat) {
        set_input_value(input1, ctx2[0].timestampFormat);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div11);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance4($$self, $$props, $$invalidate) {
  let $settings;
  component_subscribe($$self, settings, ($$value) => $$invalidate(0, $settings = $$value));
  function input0_input_handler() {
    $settings.tags = this.value;
    settings.set($settings);
  }
  function input1_input_handler() {
    $settings.timestampFormat = this.value;
    settings.set($settings);
  }
  return [$settings, input0_input_handler, input1_input_handler];
}
var CommonSettingsGroup = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance4, create_fragment4, safe_not_equal, {});
  }
};
var CommonSettingsGroup_default = CommonSettingsGroup;

// src/settings/BookmarkletSettingsGroup.svelte
function create_fragment5(ctx) {
  let div1;
  let div0;
  let t1;
  let a;
  let t2;
  let t3;
  let t4;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      div0.textContent = "You can drag or copy the link below to your browser bookmark bar. This\n		bookmarklet will allow you to highlight information on the web and send it\n		to obsidian";
      t1 = space();
      a = element("a");
      t2 = text("Obsidian Clipper (");
      t3 = text(ctx[0]);
      t4 = text(")");
      attr(a, "href", ctx[1]);
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div1, t1);
      append(div1, a);
      append(a, t2);
      append(a, t3);
      append(a, t4);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1)
        set_data(t3, ctx2[0]);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div1);
    }
  };
}
function instance5($$self, $$props, $$invalidate) {
  let { vaultName } = $$props;
  let clipperHref = new BookmarketlGenerator(vaultName).generateBookmarklet();
  $$self.$$set = ($$props2) => {
    if ("vaultName" in $$props2)
      $$invalidate(0, vaultName = $$props2.vaultName);
  };
  return [vaultName, clipperHref];
}
var BookmarkletSettingsGroup = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance5, create_fragment5, safe_not_equal, { vaultName: 0 });
  }
};
var BookmarkletSettingsGroup_default = BookmarkletSettingsGroup;

// src/settings/BaseSettingsTab.svelte
function create_fragment6(ctx) {
  let dailysettingsgroup;
  let t0;
  let weeklysettingsgroup;
  let t1;
  let commonsettingsgroup;
  let t2;
  let bookmarkletsettingsgroup;
  let current;
  dailysettingsgroup = new DailySettingsGroup_default({ props: { app: ctx[0] } });
  weeklysettingsgroup = new WeeklySettingsGroup_default({ props: { app: ctx[0] } });
  commonsettingsgroup = new CommonSettingsGroup_default({});
  bookmarkletsettingsgroup = new BookmarkletSettingsGroup_default({
    props: { vaultName: ctx[1] }
  });
  return {
    c() {
      create_component(dailysettingsgroup.$$.fragment);
      t0 = space();
      create_component(weeklysettingsgroup.$$.fragment);
      t1 = space();
      create_component(commonsettingsgroup.$$.fragment);
      t2 = space();
      create_component(bookmarkletsettingsgroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(dailysettingsgroup, target, anchor);
      insert(target, t0, anchor);
      mount_component(weeklysettingsgroup, target, anchor);
      insert(target, t1, anchor);
      mount_component(commonsettingsgroup, target, anchor);
      insert(target, t2, anchor);
      mount_component(bookmarkletsettingsgroup, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const dailysettingsgroup_changes = {};
      if (dirty & 1)
        dailysettingsgroup_changes.app = ctx2[0];
      dailysettingsgroup.$set(dailysettingsgroup_changes);
      const weeklysettingsgroup_changes = {};
      if (dirty & 1)
        weeklysettingsgroup_changes.app = ctx2[0];
      weeklysettingsgroup.$set(weeklysettingsgroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dailysettingsgroup.$$.fragment, local);
      transition_in(weeklysettingsgroup.$$.fragment, local);
      transition_in(commonsettingsgroup.$$.fragment, local);
      transition_in(bookmarkletsettingsgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dailysettingsgroup.$$.fragment, local);
      transition_out(weeklysettingsgroup.$$.fragment, local);
      transition_out(commonsettingsgroup.$$.fragment, local);
      transition_out(bookmarkletsettingsgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dailysettingsgroup, detaching);
      if (detaching)
        detach(t0);
      destroy_component(weeklysettingsgroup, detaching);
      if (detaching)
        detach(t1);
      destroy_component(commonsettingsgroup, detaching);
      if (detaching)
        detach(t2);
      destroy_component(bookmarkletsettingsgroup, detaching);
    }
  };
}
function instance6($$self, $$props, $$invalidate) {
  let { app } = $$props;
  const vaultName = app.vault.getName();
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
  };
  return [app, vaultName];
}
var BaseSettingsTab = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance6, create_fragment6, safe_not_equal, { app: 0 });
  }
};
var BaseSettingsTab_default = BaseSettingsTab;

// src/settings/MarkdownSettingsTab.svelte
function create_fragment7(ctx) {
  let div32;
  let div1;
  let t1;
  let div6;
  let div4;
  let t5;
  let div5;
  let input0;
  let t6;
  let div11;
  let div9;
  let t10;
  let div10;
  let input1;
  let t11;
  let div16;
  let div14;
  let t15;
  let div15;
  let input2;
  let t16;
  let div21;
  let div19;
  let t20;
  let div20;
  let input3;
  let t21;
  let div26;
  let div24;
  let t25;
  let div25;
  let input4;
  let t26;
  let div31;
  let div29;
  let t30;
  let div30;
  let input5;
  let mounted;
  let dispose;
  return {
    c() {
      div32 = element("div");
      div1 = element("div");
      div1.innerHTML = `<div class="setting-item-info"><h1 class="setting-item-name">Headings</h1></div>`;
      t1 = space();
      div6 = element("div");
      div4 = element("div");
      div4.innerHTML = `<div class="setting-item-name">H1</div> 
			<div class="setting-item-description">What should replace H1 elements found in the highlight data?</div>`;
      t5 = space();
      div5 = element("div");
      input0 = element("input");
      t6 = space();
      div11 = element("div");
      div9 = element("div");
      div9.innerHTML = `<div class="setting-item-name">H2</div> 
			<div class="setting-item-description">What should replace H2 elements found in the highlight data?</div>`;
      t10 = space();
      div10 = element("div");
      input1 = element("input");
      t11 = space();
      div16 = element("div");
      div14 = element("div");
      div14.innerHTML = `<div class="setting-item-name">H3</div> 
			<div class="setting-item-description">What should replace H3 elements found in the highlight data?</div>`;
      t15 = space();
      div15 = element("div");
      input2 = element("input");
      t16 = space();
      div21 = element("div");
      div19 = element("div");
      div19.innerHTML = `<div class="setting-item-name">H4</div> 
			<div class="setting-item-description">What should replace H4 elements found in the highlight data?</div>`;
      t20 = space();
      div20 = element("div");
      input3 = element("input");
      t21 = space();
      div26 = element("div");
      div24 = element("div");
      div24.innerHTML = `<div class="setting-item-name">H5</div> 
			<div class="setting-item-description">What should replace H5 elements found in the highlight data?</div>`;
      t25 = space();
      div25 = element("div");
      input4 = element("input");
      t26 = space();
      div31 = element("div");
      div29 = element("div");
      div29.innerHTML = `<div class="setting-item-name">H6</div> 
			<div class="setting-item-description">What should replace H6 elements found in the highlight data?</div>`;
      t30 = space();
      div30 = element("div");
      input5 = element("input");
      attr(div1, "class", "setting-item");
      attr(div4, "class", "setting-item-info");
      attr(input0, "type", "text");
      attr(input0, "spellcheck", "false");
      attr(input0, "placeholder", "");
      attr(div5, "class", "setting-item-control");
      attr(div6, "class", "setting-item");
      attr(div9, "class", "setting-item-info");
      attr(input1, "type", "text");
      attr(input1, "spellcheck", "false");
      attr(input1, "placeholder", "");
      attr(div10, "class", "setting-item-control");
      attr(div11, "class", "setting-item");
      attr(div14, "class", "setting-item-info");
      attr(input2, "type", "text");
      attr(input2, "spellcheck", "false");
      attr(input2, "placeholder", "");
      attr(div15, "class", "setting-item-control");
      attr(div16, "class", "setting-item");
      attr(div19, "class", "setting-item-info");
      attr(input3, "type", "text");
      attr(input3, "spellcheck", "false");
      attr(input3, "placeholder", "");
      attr(div20, "class", "setting-item-control");
      attr(div21, "class", "setting-item");
      attr(div24, "class", "setting-item-info");
      attr(input4, "type", "text");
      attr(input4, "spellcheck", "false");
      attr(input4, "placeholder", "");
      attr(div25, "class", "setting-item-control");
      attr(div26, "class", "setting-item");
      attr(div29, "class", "setting-item-info");
      attr(input5, "type", "text");
      attr(input5, "spellcheck", "false");
      attr(input5, "placeholder", "");
      attr(div30, "class", "setting-item-control");
      attr(div31, "class", "setting-item");
      attr(div32, "class", "clp_section_margin");
    },
    m(target, anchor) {
      insert(target, div32, anchor);
      append(div32, div1);
      append(div32, t1);
      append(div32, div6);
      append(div6, div4);
      append(div6, t5);
      append(div6, div5);
      append(div5, input0);
      set_input_value(input0, ctx[0].markdownSettings.h1);
      append(div32, t6);
      append(div32, div11);
      append(div11, div9);
      append(div11, t10);
      append(div11, div10);
      append(div10, input1);
      set_input_value(input1, ctx[0].markdownSettings.h2);
      append(div32, t11);
      append(div32, div16);
      append(div16, div14);
      append(div16, t15);
      append(div16, div15);
      append(div15, input2);
      set_input_value(input2, ctx[0].markdownSettings.h3);
      append(div32, t16);
      append(div32, div21);
      append(div21, div19);
      append(div21, t20);
      append(div21, div20);
      append(div20, input3);
      set_input_value(input3, ctx[0].markdownSettings.h4);
      append(div32, t21);
      append(div32, div26);
      append(div26, div24);
      append(div26, t25);
      append(div26, div25);
      append(div25, input4);
      set_input_value(input4, ctx[0].markdownSettings.h5);
      append(div32, t26);
      append(div32, div31);
      append(div31, div29);
      append(div31, t30);
      append(div31, div30);
      append(div30, input5);
      set_input_value(input5, ctx[0].markdownSettings.h6);
      if (!mounted) {
        dispose = [
          listen(input0, "input", ctx[1]),
          listen(input1, "input", ctx[2]),
          listen(input2, "input", ctx[3]),
          listen(input3, "input", ctx[4]),
          listen(input4, "input", ctx[5]),
          listen(input5, "input", ctx[6])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 1 && input0.value !== ctx2[0].markdownSettings.h1) {
        set_input_value(input0, ctx2[0].markdownSettings.h1);
      }
      if (dirty & 1 && input1.value !== ctx2[0].markdownSettings.h2) {
        set_input_value(input1, ctx2[0].markdownSettings.h2);
      }
      if (dirty & 1 && input2.value !== ctx2[0].markdownSettings.h3) {
        set_input_value(input2, ctx2[0].markdownSettings.h3);
      }
      if (dirty & 1 && input3.value !== ctx2[0].markdownSettings.h4) {
        set_input_value(input3, ctx2[0].markdownSettings.h4);
      }
      if (dirty & 1 && input4.value !== ctx2[0].markdownSettings.h5) {
        set_input_value(input4, ctx2[0].markdownSettings.h5);
      }
      if (dirty & 1 && input5.value !== ctx2[0].markdownSettings.h6) {
        set_input_value(input5, ctx2[0].markdownSettings.h6);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div32);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance7($$self, $$props, $$invalidate) {
  let $settings;
  component_subscribe($$self, settings, ($$value) => $$invalidate(0, $settings = $$value));
  function input0_input_handler() {
    $settings.markdownSettings.h1 = this.value;
    settings.set($settings);
  }
  function input1_input_handler() {
    $settings.markdownSettings.h2 = this.value;
    settings.set($settings);
  }
  function input2_input_handler() {
    $settings.markdownSettings.h3 = this.value;
    settings.set($settings);
  }
  function input3_input_handler() {
    $settings.markdownSettings.h4 = this.value;
    settings.set($settings);
  }
  function input4_input_handler() {
    $settings.markdownSettings.h5 = this.value;
    settings.set($settings);
  }
  function input5_input_handler() {
    $settings.markdownSettings.h6 = this.value;
    settings.set($settings);
  }
  return [
    $settings,
    input0_input_handler,
    input1_input_handler,
    input2_input_handler,
    input3_input_handler,
    input4_input_handler,
    input5_input_handler
  ];
}
var MarkdownSettingsTab = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance7, create_fragment7, safe_not_equal, {});
  }
};
var MarkdownSettingsTab_default = MarkdownSettingsTab;

// src/settings/Tabs.svelte
function add_css2(target) {
  append_styles(target, "svelte-lcqvkr", ".obs_clp_box.svelte-lcqvkr.svelte-lcqvkr{margin-bottom:10px;padding:40px;border:1px solid #dee2e6;border-radius:0 0 0.5rem 0.5rem;border-top:0}ul.svelte-lcqvkr.svelte-lcqvkr{display:flex;flex-wrap:wrap;padding-left:0;margin-bottom:0;list-style:none;border-bottom:1px solid #dee2e6}li.svelte-lcqvkr.svelte-lcqvkr{margin-bottom:-1px}span.svelte-lcqvkr.svelte-lcqvkr{border:1px solid transparent;border-top-left-radius:0.25rem;border-top-right-radius:0.25rem;display:block;padding:0.5rem 1rem;cursor:pointer}span.svelte-lcqvkr.svelte-lcqvkr:hover{border-color:#e9ecef #e9ecef #dee2e6}li.active.svelte-lcqvkr>span.svelte-lcqvkr{color:#495057;background-color:#fff;border-color:#dee2e6 #dee2e6 #fff}");
}
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i];
  return child_ctx;
}
function create_each_block_1(ctx) {
  let li;
  let span;
  let t0_value = ctx[5].label + "";
  let t0;
  let t1;
  let li_class_value;
  let mounted;
  let dispose;
  function keypress_handler() {
    return ctx[3](ctx[5]);
  }
  function click_handler() {
    return ctx[4](ctx[5]);
  }
  return {
    c() {
      li = element("li");
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      attr(span, "class", "svelte-lcqvkr");
      attr(li, "class", li_class_value = null_to_empty(ctx[0] === ctx[5].value ? "active" : "") + " svelte-lcqvkr");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, span);
      append(span, t0);
      append(li, t1);
      if (!mounted) {
        dispose = [
          listen(span, "keypress", keypress_handler),
          listen(span, "click", click_handler)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 2 && t0_value !== (t0_value = ctx[5].label + ""))
        set_data(t0, t0_value);
      if (dirty & 3 && li_class_value !== (li_class_value = null_to_empty(ctx[0] === ctx[5].value ? "active" : "") + " svelte-lcqvkr")) {
        attr(li, "class", li_class_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(li);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block4(ctx) {
  let div;
  let switch_instance;
  let t;
  let current;
  const switch_instance_spread_levels = [ctx[5].props];
  var switch_value = ctx[5].component;
  function switch_props(ctx2) {
    let switch_instance_props = {};
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      div = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      t = space();
      attr(div, "class", "obs_clp_box svelte-lcqvkr");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (switch_instance)
        mount_component(switch_instance, div, null);
      append(div, t);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = dirty & 2 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(ctx2[5].props)]) : {};
      if (switch_value !== (switch_value = ctx2[5].component)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div, t);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (switch_instance)
        destroy_component(switch_instance);
    }
  };
}
function create_each_block2(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[0] == ctx[5].value && create_if_block4(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[0] == ctx2[5].value) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 3) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block4(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment8(ctx) {
  let ul;
  let t;
  let each1_anchor;
  let current;
  let each_value_1 = ctx[1];
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  let each_value = ctx[1];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      ul = element("ul");
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each1_anchor = empty();
      attr(ul, "class", "svelte-lcqvkr");
    },
    m(target, anchor) {
      insert(target, ul, anchor);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].m(ul, null);
      }
      insert(target, t, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each1_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & 7) {
        each_value_1 = ctx2[1];
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
          } else {
            each_blocks_1[i] = create_each_block_1(child_ctx);
            each_blocks_1[i].c();
            each_blocks_1[i].m(ul, null);
          }
        }
        for (; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].d(1);
        }
        each_blocks_1.length = each_value_1.length;
      }
      if (dirty & 3) {
        each_value = ctx2[1];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each1_anchor.parentNode, each1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(ul);
      destroy_each(each_blocks_1, detaching);
      if (detaching)
        detach(t);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each1_anchor);
    }
  };
}
function instance8($$self, $$props, $$invalidate) {
  let { tabs } = $$props;
  let { activeTabValue = 1 } = $$props;
  const handleClick = (tabValue) => $$invalidate(0, activeTabValue = tabValue);
  const keypress_handler = (tab) => handleClick(tab.value);
  const click_handler = (tab) => handleClick(tab.value);
  $$self.$$set = ($$props2) => {
    if ("tabs" in $$props2)
      $$invalidate(1, tabs = $$props2.tabs);
    if ("activeTabValue" in $$props2)
      $$invalidate(0, activeTabValue = $$props2.activeTabValue);
  };
  return [activeTabValue, tabs, handleClick, keypress_handler, click_handler];
}
var Tabs = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance8, create_fragment8, safe_not_equal, { tabs: 1, activeTabValue: 0 }, add_css2);
  }
};
var Tabs_default = Tabs;

// src/settings/Notice.svelte
function create_fragment9(ctx) {
  let div3;
  return {
    c() {
      div3 = element("div");
      div3.innerHTML = `<div class="flex"><div class="flex-shrink-0"><svg class="h-5 w-5 text-blue-400" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a.75.75 0 000 1.5h.253a.25.25 0 01.244.304l-.459 2.066A1.75 1.75 0 0010.747 15H11a.75.75 0 000-1.5h-.253a.25.25 0 01-.244-.304l.459-2.066A1.75 1.75 0 009.253 9H9z" clip-rule="evenodd"></path></svg></div> 
		<div class="ml-3 flex-1 md:flex md:justify-between"><p class="text-sm text-blue-700">Please reinstall the BookMarketlet link found below. Significant changes
				were made to this plugin and the updated bookmarklet takes advantage of
				these changes.</p> 
			<p class="mt-3 text-sm md:mt-0 md:ml-6"><a href="https://github.com/jgchristopher/obsidian-clipper#obsidian-clipper" class="whitespace-nowrap font-medium text-blue-700 hover:text-blue-600">Details
					<span aria-hidden="true">\u2192</span></a></p></div></div>`;
      attr(div3, "class", "rounded-md bg-blue-50 p-4");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div3);
    }
  };
}
var Notice5 = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment9, safe_not_equal, {});
  }
};
var Notice_default = Notice5;

// src/settings/TopicSettingsGroup.svelte
function create_fragment10(ctx) {
  let div10;
  let div4;
  let div2;
  let t3;
  let div3;
  let select0;
  let option0;
  let option1;
  let t6;
  let div9;
  let div7;
  let t10;
  let div8;
  let select1;
  let option2;
  let option2_value_value;
  let option3;
  let option3_value_value;
  let t13;
  let suggest;
  let current;
  let mounted;
  let dispose;
  suggest = new Suggest_default({
    props: {
      name: "Clipped Entry Template - Topic",
      description: "Choose the file to use as a template for the clipped entry a topic note",
      initialValue: ctx[1].topicEntryTemplateLocation,
      dataProvider: ctx[5],
      onChange: ctx[2]
    }
  });
  return {
    c() {
      div10 = element("div");
      div4 = element("div");
      div2 = element("div");
      div2.innerHTML = `<div class="setting-item-name">Topic Note Position</div> 
			<div class="setting-item-description">Would you like to prepend clippings or append them to the bottom?</div>`;
      t3 = space();
      div3 = element("div");
      select0 = element("select");
      option0 = element("option");
      option0.textContent = "prepend";
      option1 = element("option");
      option1.textContent = "append";
      t6 = space();
      div9 = element("div");
      div7 = element("div");
      div7.innerHTML = `<div class="setting-item-name">Open File After Adding Clipping?</div> 
			<div class="setting-item-description">Would you like to open the note after adding the clipping?</div>`;
      t10 = space();
      div8 = element("div");
      select1 = element("select");
      option2 = element("option");
      option2.textContent = "Yes";
      option3 = element("option");
      option3.textContent = "No";
      t13 = space();
      create_component(suggest.$$.fragment);
      attr(div2, "class", "setting-item-info");
      option0.__value = "prepend";
      option0.value = option0.__value;
      option1.__value = "append";
      option1.value = option1.__value;
      attr(select0, "class", "dropdown");
      if (ctx[1].topicPosition === void 0)
        add_render_callback(() => ctx[3].call(select0));
      attr(div3, "class", "setting-item-control");
      attr(div4, "class", "setting-item");
      attr(div7, "class", "setting-item-info");
      option2.__value = option2_value_value = true;
      option2.value = option2.__value;
      option3.__value = option3_value_value = false;
      option3.value = option3.__value;
      attr(select1, "class", "dropdown");
      if (ctx[1].topicOpenOnWrite === void 0)
        add_render_callback(() => ctx[4].call(select1));
      attr(div8, "class", "setting-item-control");
      attr(div9, "class", "setting-item");
      attr(div10, "class", "clp_section_margin");
    },
    m(target, anchor) {
      insert(target, div10, anchor);
      append(div10, div4);
      append(div4, div2);
      append(div4, t3);
      append(div4, div3);
      append(div3, select0);
      append(select0, option0);
      append(select0, option1);
      select_option(select0, ctx[1].topicPosition);
      append(div10, t6);
      append(div10, div9);
      append(div9, div7);
      append(div9, t10);
      append(div9, div8);
      append(div8, select1);
      append(select1, option2);
      append(select1, option3);
      select_option(select1, ctx[1].topicOpenOnWrite);
      append(div10, t13);
      mount_component(suggest, div10, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(select0, "change", ctx[3]),
          listen(select1, "change", ctx[4])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 2) {
        select_option(select0, ctx2[1].topicPosition);
      }
      if (dirty & 2) {
        select_option(select1, ctx2[1].topicOpenOnWrite);
      }
      const suggest_changes = {};
      if (dirty & 2)
        suggest_changes.initialValue = ctx2[1].topicEntryTemplateLocation;
      if (dirty & 1)
        suggest_changes.dataProvider = ctx2[5];
      suggest.$set(suggest_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(suggest.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(suggest.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div10);
      destroy_component(suggest);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance9($$self, $$props, $$invalidate) {
  let $settings;
  component_subscribe($$self, settings, ($$value) => $$invalidate(1, $settings = $$value));
  let { app } = $$props;
  const onChange = (entry) => {
    set_store_value(settings, $settings.topicEntryTemplateLocation = entry, $settings);
  };
  function select0_change_handler() {
    $settings.topicPosition = select_value(this);
    settings.set($settings);
  }
  function select1_change_handler() {
    $settings.topicOpenOnWrite = select_value(this);
    settings.set($settings);
  }
  const func = () => app.vault.getMarkdownFiles();
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
  };
  return [app, $settings, onChange, select0_change_handler, select1_change_handler, func];
}
var TopicSettingsGroup = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance9, create_fragment10, safe_not_equal, { app: 0 });
  }
};
var TopicSettingsGroup_default = TopicSettingsGroup;

// src/settings/TopicSettingsTab.svelte
function create_fragment11(ctx) {
  let topicsettingsgroup;
  let current;
  topicsettingsgroup = new TopicSettingsGroup_default({ props: { app: ctx[0] } });
  return {
    c() {
      create_component(topicsettingsgroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(topicsettingsgroup, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const topicsettingsgroup_changes = {};
      if (dirty & 1)
        topicsettingsgroup_changes.app = ctx2[0];
      topicsettingsgroup.$set(topicsettingsgroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(topicsettingsgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(topicsettingsgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(topicsettingsgroup, detaching);
    }
  };
}
function instance10($$self, $$props, $$invalidate) {
  let { app } = $$props;
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
  };
  return [app];
}
var TopicSettingsTab = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance10, create_fragment11, safe_not_equal, { app: 0 });
  }
};
var TopicSettingsTab_default = TopicSettingsTab;

// src/settings/SettingsComponent.svelte
function create_fragment12(ctx) {
  let notice;
  let t0;
  let br;
  let t1;
  let tabs_1;
  let current;
  notice = new Notice_default({});
  tabs_1 = new Tabs_default({ props: { tabs: ctx[0] } });
  return {
    c() {
      create_component(notice.$$.fragment);
      t0 = space();
      br = element("br");
      t1 = space();
      create_component(tabs_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(notice, target, anchor);
      insert(target, t0, anchor);
      insert(target, br, anchor);
      insert(target, t1, anchor);
      mount_component(tabs_1, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(notice.$$.fragment, local);
      transition_in(tabs_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(notice.$$.fragment, local);
      transition_out(tabs_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(notice, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(br);
      if (detaching)
        detach(t1);
      destroy_component(tabs_1, detaching);
    }
  };
}
function instance11($$self, $$props, $$invalidate) {
  let { app } = $$props;
  let tabs = [
    {
      label: "Base Settings",
      value: 1,
      component: BaseSettingsTab_default,
      props: { app }
    },
    {
      label: "Topic Note Settings",
      value: 2,
      component: TopicSettingsTab_default,
      props: { app }
    },
    {
      label: "Markdown Settings",
      value: 3,
      component: MarkdownSettingsTab_default
    }
  ];
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(1, app = $$props2.app);
  };
  return [tabs, app];
}
var SettingsComponent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance11, create_fragment12, safe_not_equal, { app: 1 });
  }
};
var SettingsComponent_default = SettingsComponent;

// node_modules/turndown/lib/turndown.browser.es.js
function extend(destination) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (source.hasOwnProperty(key))
        destination[key] = source[key];
    }
  }
  return destination;
}
function repeat(character, count) {
  return Array(count + 1).join(character);
}
function trimLeadingNewlines(string) {
  return string.replace(/^\n*/, "");
}
function trimTrailingNewlines(string) {
  var indexEnd = string.length;
  while (indexEnd > 0 && string[indexEnd - 1] === "\n")
    indexEnd--;
  return string.substring(0, indexEnd);
}
var blockElements = [
  "ADDRESS",
  "ARTICLE",
  "ASIDE",
  "AUDIO",
  "BLOCKQUOTE",
  "BODY",
  "CANVAS",
  "CENTER",
  "DD",
  "DIR",
  "DIV",
  "DL",
  "DT",
  "FIELDSET",
  "FIGCAPTION",
  "FIGURE",
  "FOOTER",
  "FORM",
  "FRAMESET",
  "H1",
  "H2",
  "H3",
  "H4",
  "H5",
  "H6",
  "HEADER",
  "HGROUP",
  "HR",
  "HTML",
  "ISINDEX",
  "LI",
  "MAIN",
  "MENU",
  "NAV",
  "NOFRAMES",
  "NOSCRIPT",
  "OL",
  "OUTPUT",
  "P",
  "PRE",
  "SECTION",
  "TABLE",
  "TBODY",
  "TD",
  "TFOOT",
  "TH",
  "THEAD",
  "TR",
  "UL"
];
function isBlock(node) {
  return is(node, blockElements);
}
var voidElements = [
  "AREA",
  "BASE",
  "BR",
  "COL",
  "COMMAND",
  "EMBED",
  "HR",
  "IMG",
  "INPUT",
  "KEYGEN",
  "LINK",
  "META",
  "PARAM",
  "SOURCE",
  "TRACK",
  "WBR"
];
function isVoid(node) {
  return is(node, voidElements);
}
function hasVoid(node) {
  return has(node, voidElements);
}
var meaningfulWhenBlankElements = [
  "A",
  "TABLE",
  "THEAD",
  "TBODY",
  "TFOOT",
  "TH",
  "TD",
  "IFRAME",
  "SCRIPT",
  "AUDIO",
  "VIDEO"
];
function isMeaningfulWhenBlank(node) {
  return is(node, meaningfulWhenBlankElements);
}
function hasMeaningfulWhenBlank(node) {
  return has(node, meaningfulWhenBlankElements);
}
function is(node, tagNames) {
  return tagNames.indexOf(node.nodeName) >= 0;
}
function has(node, tagNames) {
  return node.getElementsByTagName && tagNames.some(function(tagName) {
    return node.getElementsByTagName(tagName).length;
  });
}
var rules = {};
rules.paragraph = {
  filter: "p",
  replacement: function(content) {
    return "\n\n" + content + "\n\n";
  }
};
rules.lineBreak = {
  filter: "br",
  replacement: function(content, node, options) {
    return options.br + "\n";
  }
};
rules.heading = {
  filter: ["h1", "h2", "h3", "h4", "h5", "h6"],
  replacement: function(content, node, options) {
    var hLevel = Number(node.nodeName.charAt(1));
    if (options.headingStyle === "setext" && hLevel < 3) {
      var underline = repeat(hLevel === 1 ? "=" : "-", content.length);
      return "\n\n" + content + "\n" + underline + "\n\n";
    } else {
      return "\n\n" + repeat("#", hLevel) + " " + content + "\n\n";
    }
  }
};
rules.blockquote = {
  filter: "blockquote",
  replacement: function(content) {
    content = content.replace(/^\n+|\n+$/g, "");
    content = content.replace(/^/gm, "> ");
    return "\n\n" + content + "\n\n";
  }
};
rules.list = {
  filter: ["ul", "ol"],
  replacement: function(content, node) {
    var parent = node.parentNode;
    if (parent.nodeName === "LI" && parent.lastElementChild === node) {
      return "\n" + content;
    } else {
      return "\n\n" + content + "\n\n";
    }
  }
};
rules.listItem = {
  filter: "li",
  replacement: function(content, node, options) {
    content = content.replace(/^\n+/, "").replace(/\n+$/, "\n").replace(/\n/gm, "\n    ");
    var prefix = options.bulletListMarker + "   ";
    var parent = node.parentNode;
    if (parent.nodeName === "OL") {
      var start2 = parent.getAttribute("start");
      var index = Array.prototype.indexOf.call(parent.children, node);
      prefix = (start2 ? Number(start2) + index : index + 1) + ".  ";
    }
    return prefix + content + (node.nextSibling && !/\n$/.test(content) ? "\n" : "");
  }
};
rules.indentedCodeBlock = {
  filter: function(node, options) {
    return options.codeBlockStyle === "indented" && node.nodeName === "PRE" && node.firstChild && node.firstChild.nodeName === "CODE";
  },
  replacement: function(content, node, options) {
    return "\n\n    " + node.firstChild.textContent.replace(/\n/g, "\n    ") + "\n\n";
  }
};
rules.fencedCodeBlock = {
  filter: function(node, options) {
    return options.codeBlockStyle === "fenced" && node.nodeName === "PRE" && node.firstChild && node.firstChild.nodeName === "CODE";
  },
  replacement: function(content, node, options) {
    var className = node.firstChild.getAttribute("class") || "";
    var language = (className.match(/language-(\S+)/) || [null, ""])[1];
    var code = node.firstChild.textContent;
    var fenceChar = options.fence.charAt(0);
    var fenceSize = 3;
    var fenceInCodeRegex = new RegExp("^" + fenceChar + "{3,}", "gm");
    var match;
    while (match = fenceInCodeRegex.exec(code)) {
      if (match[0].length >= fenceSize) {
        fenceSize = match[0].length + 1;
      }
    }
    var fence = repeat(fenceChar, fenceSize);
    return "\n\n" + fence + language + "\n" + code.replace(/\n$/, "") + "\n" + fence + "\n\n";
  }
};
rules.horizontalRule = {
  filter: "hr",
  replacement: function(content, node, options) {
    return "\n\n" + options.hr + "\n\n";
  }
};
rules.inlineLink = {
  filter: function(node, options) {
    return options.linkStyle === "inlined" && node.nodeName === "A" && node.getAttribute("href");
  },
  replacement: function(content, node) {
    var href = node.getAttribute("href");
    var title = cleanAttribute(node.getAttribute("title"));
    if (title)
      title = ' "' + title + '"';
    return "[" + content + "](" + href + title + ")";
  }
};
rules.referenceLink = {
  filter: function(node, options) {
    return options.linkStyle === "referenced" && node.nodeName === "A" && node.getAttribute("href");
  },
  replacement: function(content, node, options) {
    var href = node.getAttribute("href");
    var title = cleanAttribute(node.getAttribute("title"));
    if (title)
      title = ' "' + title + '"';
    var replacement;
    var reference2;
    switch (options.linkReferenceStyle) {
      case "collapsed":
        replacement = "[" + content + "][]";
        reference2 = "[" + content + "]: " + href + title;
        break;
      case "shortcut":
        replacement = "[" + content + "]";
        reference2 = "[" + content + "]: " + href + title;
        break;
      default:
        var id = this.references.length + 1;
        replacement = "[" + content + "][" + id + "]";
        reference2 = "[" + id + "]: " + href + title;
    }
    this.references.push(reference2);
    return replacement;
  },
  references: [],
  append: function(options) {
    var references = "";
    if (this.references.length) {
      references = "\n\n" + this.references.join("\n") + "\n\n";
      this.references = [];
    }
    return references;
  }
};
rules.emphasis = {
  filter: ["em", "i"],
  replacement: function(content, node, options) {
    if (!content.trim())
      return "";
    return options.emDelimiter + content + options.emDelimiter;
  }
};
rules.strong = {
  filter: ["strong", "b"],
  replacement: function(content, node, options) {
    if (!content.trim())
      return "";
    return options.strongDelimiter + content + options.strongDelimiter;
  }
};
rules.code = {
  filter: function(node) {
    var hasSiblings = node.previousSibling || node.nextSibling;
    var isCodeBlock = node.parentNode.nodeName === "PRE" && !hasSiblings;
    return node.nodeName === "CODE" && !isCodeBlock;
  },
  replacement: function(content) {
    if (!content)
      return "";
    content = content.replace(/\r?\n|\r/g, " ");
    var extraSpace = /^`|^ .*?[^ ].* $|`$/.test(content) ? " " : "";
    var delimiter = "`";
    var matches = content.match(/`+/gm) || [];
    while (matches.indexOf(delimiter) !== -1)
      delimiter = delimiter + "`";
    return delimiter + extraSpace + content + extraSpace + delimiter;
  }
};
rules.image = {
  filter: "img",
  replacement: function(content, node) {
    var alt = cleanAttribute(node.getAttribute("alt"));
    var src = node.getAttribute("src") || "";
    var title = cleanAttribute(node.getAttribute("title"));
    var titlePart = title ? ' "' + title + '"' : "";
    return src ? "![" + alt + "](" + src + titlePart + ")" : "";
  }
};
function cleanAttribute(attribute) {
  return attribute ? attribute.replace(/(\n+\s*)+/g, "\n") : "";
}
function Rules(options) {
  this.options = options;
  this._keep = [];
  this._remove = [];
  this.blankRule = {
    replacement: options.blankReplacement
  };
  this.keepReplacement = options.keepReplacement;
  this.defaultRule = {
    replacement: options.defaultReplacement
  };
  this.array = [];
  for (var key in options.rules)
    this.array.push(options.rules[key]);
}
Rules.prototype = {
  add: function(key, rule) {
    this.array.unshift(rule);
  },
  keep: function(filter) {
    this._keep.unshift({
      filter,
      replacement: this.keepReplacement
    });
  },
  remove: function(filter) {
    this._remove.unshift({
      filter,
      replacement: function() {
        return "";
      }
    });
  },
  forNode: function(node) {
    if (node.isBlank)
      return this.blankRule;
    var rule;
    if (rule = findRule(this.array, node, this.options))
      return rule;
    if (rule = findRule(this._keep, node, this.options))
      return rule;
    if (rule = findRule(this._remove, node, this.options))
      return rule;
    return this.defaultRule;
  },
  forEach: function(fn2) {
    for (var i = 0; i < this.array.length; i++)
      fn2(this.array[i], i);
  }
};
function findRule(rules2, node, options) {
  for (var i = 0; i < rules2.length; i++) {
    var rule = rules2[i];
    if (filterValue(rule, node, options))
      return rule;
  }
  return void 0;
}
function filterValue(rule, node, options) {
  var filter = rule.filter;
  if (typeof filter === "string") {
    if (filter === node.nodeName.toLowerCase())
      return true;
  } else if (Array.isArray(filter)) {
    if (filter.indexOf(node.nodeName.toLowerCase()) > -1)
      return true;
  } else if (typeof filter === "function") {
    if (filter.call(rule, node, options))
      return true;
  } else {
    throw new TypeError("`filter` needs to be a string, array, or function");
  }
}
function collapseWhitespace(options) {
  var element2 = options.element;
  var isBlock2 = options.isBlock;
  var isVoid2 = options.isVoid;
  var isPre = options.isPre || function(node2) {
    return node2.nodeName === "PRE";
  };
  if (!element2.firstChild || isPre(element2))
    return;
  var prevText = null;
  var keepLeadingWs = false;
  var prev = null;
  var node = next(prev, element2, isPre);
  while (node !== element2) {
    if (node.nodeType === 3 || node.nodeType === 4) {
      var text2 = node.data.replace(/[ \r\n\t]+/g, " ");
      if ((!prevText || / $/.test(prevText.data)) && !keepLeadingWs && text2[0] === " ") {
        text2 = text2.substr(1);
      }
      if (!text2) {
        node = remove(node);
        continue;
      }
      node.data = text2;
      prevText = node;
    } else if (node.nodeType === 1) {
      if (isBlock2(node) || node.nodeName === "BR") {
        if (prevText) {
          prevText.data = prevText.data.replace(/ $/, "");
        }
        prevText = null;
        keepLeadingWs = false;
      } else if (isVoid2(node) || isPre(node)) {
        prevText = null;
        keepLeadingWs = true;
      } else if (prevText) {
        keepLeadingWs = false;
      }
    } else {
      node = remove(node);
      continue;
    }
    var nextNode = next(prev, node, isPre);
    prev = node;
    node = nextNode;
  }
  if (prevText) {
    prevText.data = prevText.data.replace(/ $/, "");
    if (!prevText.data) {
      remove(prevText);
    }
  }
}
function remove(node) {
  var next2 = node.nextSibling || node.parentNode;
  node.parentNode.removeChild(node);
  return next2;
}
function next(prev, current, isPre) {
  if (prev && prev.parentNode === current || isPre(current)) {
    return current.nextSibling || current.parentNode;
  }
  return current.firstChild || current.nextSibling || current.parentNode;
}
var root = typeof window !== "undefined" ? window : {};
function canParseHTMLNatively() {
  var Parser = root.DOMParser;
  var canParse = false;
  try {
    if (new Parser().parseFromString("", "text/html")) {
      canParse = true;
    }
  } catch (e) {
  }
  return canParse;
}
function createHTMLParser() {
  var Parser = function() {
  };
  {
    if (shouldUseActiveX()) {
      Parser.prototype.parseFromString = function(string) {
        var doc = new window.ActiveXObject("htmlfile");
        doc.designMode = "on";
        doc.open();
        doc.write(string);
        doc.close();
        return doc;
      };
    } else {
      Parser.prototype.parseFromString = function(string) {
        var doc = document.implementation.createHTMLDocument("");
        doc.open();
        doc.write(string);
        doc.close();
        return doc;
      };
    }
  }
  return Parser;
}
function shouldUseActiveX() {
  var useActiveX = false;
  try {
    document.implementation.createHTMLDocument("").open();
  } catch (e) {
    if (window.ActiveXObject)
      useActiveX = true;
  }
  return useActiveX;
}
var HTMLParser = canParseHTMLNatively() ? root.DOMParser : createHTMLParser();
function RootNode(input, options) {
  var root2;
  if (typeof input === "string") {
    var doc = htmlParser().parseFromString('<x-turndown id="turndown-root">' + input + "</x-turndown>", "text/html");
    root2 = doc.getElementById("turndown-root");
  } else {
    root2 = input.cloneNode(true);
  }
  collapseWhitespace({
    element: root2,
    isBlock,
    isVoid,
    isPre: options.preformattedCode ? isPreOrCode : null
  });
  return root2;
}
var _htmlParser;
function htmlParser() {
  _htmlParser = _htmlParser || new HTMLParser();
  return _htmlParser;
}
function isPreOrCode(node) {
  return node.nodeName === "PRE" || node.nodeName === "CODE";
}
function Node(node, options) {
  node.isBlock = isBlock(node);
  node.isCode = node.nodeName === "CODE" || node.parentNode.isCode;
  node.isBlank = isBlank(node);
  node.flankingWhitespace = flankingWhitespace(node, options);
  return node;
}
function isBlank(node) {
  return !isVoid(node) && !isMeaningfulWhenBlank(node) && /^\s*$/i.test(node.textContent) && !hasVoid(node) && !hasMeaningfulWhenBlank(node);
}
function flankingWhitespace(node, options) {
  if (node.isBlock || options.preformattedCode && node.isCode) {
    return { leading: "", trailing: "" };
  }
  var edges = edgeWhitespace(node.textContent);
  if (edges.leadingAscii && isFlankedByWhitespace("left", node, options)) {
    edges.leading = edges.leadingNonAscii;
  }
  if (edges.trailingAscii && isFlankedByWhitespace("right", node, options)) {
    edges.trailing = edges.trailingNonAscii;
  }
  return { leading: edges.leading, trailing: edges.trailing };
}
function edgeWhitespace(string) {
  var m = string.match(/^(([ \t\r\n]*)(\s*))[\s\S]*?((\s*?)([ \t\r\n]*))$/);
  return {
    leading: m[1],
    leadingAscii: m[2],
    leadingNonAscii: m[3],
    trailing: m[4],
    trailingNonAscii: m[5],
    trailingAscii: m[6]
  };
}
function isFlankedByWhitespace(side, node, options) {
  var sibling;
  var regExp;
  var isFlanked;
  if (side === "left") {
    sibling = node.previousSibling;
    regExp = / $/;
  } else {
    sibling = node.nextSibling;
    regExp = /^ /;
  }
  if (sibling) {
    if (sibling.nodeType === 3) {
      isFlanked = regExp.test(sibling.nodeValue);
    } else if (options.preformattedCode && sibling.nodeName === "CODE") {
      isFlanked = false;
    } else if (sibling.nodeType === 1 && !isBlock(sibling)) {
      isFlanked = regExp.test(sibling.textContent);
    }
  }
  return isFlanked;
}
var reduce = Array.prototype.reduce;
var escapes = [
  [/\\/g, "\\\\"],
  [/\*/g, "\\*"],
  [/^-/g, "\\-"],
  [/^\+ /g, "\\+ "],
  [/^(=+)/g, "\\$1"],
  [/^(#{1,6}) /g, "\\$1 "],
  [/`/g, "\\`"],
  [/^~~~/g, "\\~~~"],
  [/\[/g, "\\["],
  [/\]/g, "\\]"],
  [/^>/g, "\\>"],
  [/_/g, "\\_"],
  [/^(\d+)\. /g, "$1\\. "]
];
function TurndownService(options) {
  if (!(this instanceof TurndownService))
    return new TurndownService(options);
  var defaults = {
    rules,
    headingStyle: "setext",
    hr: "* * *",
    bulletListMarker: "*",
    codeBlockStyle: "indented",
    fence: "```",
    emDelimiter: "_",
    strongDelimiter: "**",
    linkStyle: "inlined",
    linkReferenceStyle: "full",
    br: "  ",
    preformattedCode: false,
    blankReplacement: function(content, node) {
      return node.isBlock ? "\n\n" : "";
    },
    keepReplacement: function(content, node) {
      return node.isBlock ? "\n\n" + node.outerHTML + "\n\n" : node.outerHTML;
    },
    defaultReplacement: function(content, node) {
      return node.isBlock ? "\n\n" + content + "\n\n" : content;
    }
  };
  this.options = extend({}, defaults, options);
  this.rules = new Rules(this.options);
}
TurndownService.prototype = {
  turndown: function(input) {
    if (!canConvert(input)) {
      throw new TypeError(input + " is not a string, or an element/document/fragment node.");
    }
    if (input === "")
      return "";
    var output = process2.call(this, new RootNode(input, this.options));
    return postProcess.call(this, output);
  },
  use: function(plugin) {
    if (Array.isArray(plugin)) {
      for (var i = 0; i < plugin.length; i++)
        this.use(plugin[i]);
    } else if (typeof plugin === "function") {
      plugin(this);
    } else {
      throw new TypeError("plugin must be a Function or an Array of Functions");
    }
    return this;
  },
  addRule: function(key, rule) {
    this.rules.add(key, rule);
    return this;
  },
  keep: function(filter) {
    this.rules.keep(filter);
    return this;
  },
  remove: function(filter) {
    this.rules.remove(filter);
    return this;
  },
  escape: function(string) {
    return escapes.reduce(function(accumulator, escape) {
      return accumulator.replace(escape[0], escape[1]);
    }, string);
  }
};
function process2(parentNode) {
  var self = this;
  return reduce.call(parentNode.childNodes, function(output, node) {
    node = new Node(node, self.options);
    var replacement = "";
    if (node.nodeType === 3) {
      replacement = node.isCode ? node.nodeValue : self.escape(node.nodeValue);
    } else if (node.nodeType === 1) {
      replacement = replacementForNode.call(self, node);
    }
    return join(output, replacement);
  }, "");
}
function postProcess(output) {
  var self = this;
  this.rules.forEach(function(rule) {
    if (typeof rule.append === "function") {
      output = join(output, rule.append(self.options));
    }
  });
  return output.replace(/^[\t\r\n]+/, "").replace(/[\t\r\n\s]+$/, "");
}
function replacementForNode(node) {
  var rule = this.rules.forNode(node);
  var content = process2.call(this, node);
  var whitespace = node.flankingWhitespace;
  if (whitespace.leading || whitespace.trailing)
    content = content.trim();
  return whitespace.leading + rule.replacement(content, node, this.options) + whitespace.trailing;
}
function join(output, replacement) {
  var s1 = trimTrailingNewlines(output);
  var s2 = trimLeadingNewlines(replacement);
  var nls = Math.max(output.length - s1.length, replacement.length - s2.length);
  var separator = "\n\n".substring(0, nls);
  return s1 + separator + s2;
}
function canConvert(input) {
  return input != null && (typeof input === "string" || input.nodeType && (input.nodeType === 1 || input.nodeType === 9 || input.nodeType === 11));
}
var turndown_browser_es_default = TurndownService;

// src/markdown/tables.ts
var MarkdownTablesHelper = class {
  static tableShouldBeSkipped(tableNode) {
    if (!tableNode)
      return true;
    if (!tableNode.rows)
      return true;
    if (tableNode.rows.length === 1 && tableNode.rows[0].childNodes.length <= 1)
      return true;
    if (MarkdownTablesHelper.nodeContainsTable(tableNode))
      return true;
    return false;
  }
  static isHeadingRow(tr) {
    const parentNode = tr.parentNode;
    let headingRow = false;
    if (parentNode) {
      if (parentNode.nodeName === "THEAD") {
        headingRow = true;
      } else if (parentNode.firstChild !== tr) {
        headingRow = false;
      } else if (parentNode.nodeName === "TABLE" || MarkdownTablesHelper.isFirstTbody(parentNode)) {
        headingRow = Array.prototype.every.call(tr.childNodes, (n) => {
          return n.nodeName === "TH";
        });
      }
    }
    return headingRow;
  }
  static isFirstTbody(element2) {
    const previousSibling = element2.previousSibling;
    let isFirstTbody = false;
    if (previousSibling) {
      if (element2.nodeName !== "TBODY") {
        isFirstTbody = false;
      } else {
        if (!previousSibling) {
          isFirstTbody = true;
        } else if (previousSibling.nodeName === "THEAD" && previousSibling.textContent && /^\s*$/i.test(previousSibling.textContent)) {
          isFirstTbody = true;
        } else {
          isFirstTbody = false;
        }
      }
    }
    return isFirstTbody;
  }
  static cell(content, node = null, index = null) {
    if (index === null && node != null) {
      if (node.parentNode) {
        index = Array.prototype.indexOf.call(node.parentNode.childNodes, node);
      }
    }
    let prefix = " ";
    if (index === 0)
      prefix = "| ";
    let filteredContent = content.trim().replace(/\n\r/g, "<br>").replace(/\n/g, "<br>");
    filteredContent = filteredContent.replace(/\|+/g, "\\|");
    while (filteredContent.length < 3)
      filteredContent += " ";
    if (node)
      filteredContent = MarkdownTablesHelper.handleColSpan(filteredContent, node, " ");
    return prefix + filteredContent + " |";
  }
  static nodeContainsTable(node) {
    if (!node.childNodes)
      return false;
    for (let i = 0; i < node.childNodes.length; i++) {
      const child = node.childNodes[i];
      if (child.nodeName === "TABLE")
        return true;
      if (MarkdownTablesHelper.nodeContainsTable(child))
        return true;
    }
    return false;
  }
  static nodeParentTable(node) {
    let parent = node.parentNode;
    if (parent) {
      while (parent && parent.nodeName !== "TABLE") {
        parent = parent.parentNode;
      }
    }
    return parent;
  }
  static handleColSpan(content, node, emptyChar) {
    const colspan = node.getAttribute("colspan") || 1;
    for (let i = 1; i < colspan; i++) {
      content += " | " + emptyChar.repeat(3);
    }
    return content;
  }
  static tableColCount(node) {
    let maxColCount = 0;
    if (node && node.rows) {
      for (let i = 0; i < node.rows.length; i++) {
        const row = node.rows[i];
        const colCount = row.childNodes.length;
        if (colCount > maxColCount)
          maxColCount = colCount;
      }
    }
    return maxColCount;
  }
};
var MarkdownTables = class {
  tables(turndownService) {
    turndownService.keep(function(node) {
      let shouldFilter = false;
      if (node.nodeName) {
        shouldFilter = node.nodeName === "TABLE";
      }
      return shouldFilter;
    });
    const rules2 = {
      tableCell: {
        filter: ["th", "td"],
        replacement: function(content, node) {
          if (MarkdownTablesHelper.tableShouldBeSkipped(MarkdownTablesHelper.nodeParentTable(node)))
            return content;
          return MarkdownTablesHelper.cell(content, node);
        }
      },
      tableRow: {
        filter: "tr",
        replacement: function(content, node) {
          const parentTable = MarkdownTablesHelper.nodeParentTable(node);
          if (MarkdownTablesHelper.tableShouldBeSkipped(parentTable))
            return content;
          let borderCells = "";
          const alignMap = {
            left: ":--",
            right: "--:",
            center: ":-:"
          };
          if (MarkdownTablesHelper.isHeadingRow(node)) {
            const colCount = MarkdownTablesHelper.tableColCount(parentTable);
            for (let i = 0; i < colCount; i++) {
              const childNode = colCount >= node.childNodes.length ? null : node.childNodes[i];
              let border = "---";
              const align = childNode ? (childNode.getAttribute("align") || "").toLowerCase() : "";
              if (align)
                border = alignMap[align] || border;
              if (childNode) {
                borderCells += MarkdownTablesHelper.cell(border, node.childNodes[i]);
              } else {
                borderCells += MarkdownTablesHelper.cell(border, null, i);
              }
            }
          }
          return "\n" + content + (borderCells ? "\n" + borderCells : "");
        }
      },
      table: {
        filter: function(node) {
          return node.nodeName === "TABLE";
        },
        replacement: function(content, node) {
          if (MarkdownTablesHelper.tableShouldBeSkipped(node))
            return content;
          content = content.replace(/\n+/g, "\n");
          let secondLine = content.trim().split("\n");
          if (secondLine.length >= 2)
            secondLine = secondLine[1];
          const secondLineIsDivider = secondLine.indexOf("| ---") === 0;
          const columnCount = MarkdownTablesHelper.tableColCount(node);
          let emptyHeader = "";
          if (columnCount && !secondLineIsDivider) {
            emptyHeader = "|" + "     |".repeat(columnCount) + "\n|" + " --- |".repeat(columnCount);
          }
          return "\n\n" + emptyHeader + content + "\n\n";
        }
      },
      tableSection: {
        filter: ["thead", "tbody", "tfoot"],
        replacement: function(content) {
          return content;
        }
      }
    };
    let k;
    for (k in rules2) {
      turndownService.addRule(k, rules2[k]);
    }
  }
};

// src/markdown/markdownprocessor.ts
var MarkdownProcessor = class {
  constructor(data) {
    this.data = data;
  }
  process(markdownSettings) {
    let markdownData = this.data;
    if (this.data) {
      const markdownService = new turndown_browser_es_default({
        headingStyle: "atx",
        hr: "---",
        bulletListMarker: "-",
        codeBlockStyle: "fenced",
        emDelimiter: "*"
      });
      const tables = new MarkdownTables();
      markdownService.use(tables.tables);
      markdownService.addRule("heading_1_update", {
        filter: ["h1"],
        replacement: function(content) {
          return `${markdownSettings.h1} ${content}`;
        }
      });
      markdownService.addRule("heading_2_update", {
        filter: ["h2"],
        replacement: function(content) {
          return `${markdownSettings.h2} ${content}`;
        }
      });
      markdownService.addRule("heading_3_update", {
        filter: ["h3"],
        replacement: function(content) {
          return `${markdownSettings.h3} ${content}`;
        }
      });
      markdownService.addRule("heading_4_update", {
        filter: ["h4"],
        replacement: function(content) {
          return `${markdownSettings.h4} ${content}`;
        }
      });
      markdownService.addRule("heading_5_update", {
        filter: ["h5"],
        replacement: function(content) {
          return `${markdownSettings.h5} ${content}`;
        }
      });
      markdownService.addRule("heading_6_update", {
        filter: ["h6"],
        replacement: function(content) {
          return `${markdownSettings.h6} ${content}`;
        }
      });
      markdownData = markdownService.turndown(this.data);
    }
    return markdownData;
  }
};

// src/topicnoteentry.ts
var TopicNoteEntry = class extends NoteEntry {
  async writeToNote(file, noteEntry) {
    Utility.assertNotNull(file);
    this.handleWrite(file.path, await noteEntry.formattedEntry(this.template));
  }
};

// src/main.ts
var ObsidianClipperPlugin = class extends import_obsidian5.Plugin {
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new SettingTab(this.app, this));
    this.addCommand({
      id: "copy-bookmarklet-address",
      name: "Vault Bookmarklet",
      callback: () => this.handleCopyBookmarkletCommand()
    });
    this.addCommand({
      id: "copy-note-bookmarklet-address",
      name: "Note Bookmarklet",
      editorCallback: (_editor, ctx) => {
        this.handleSubjectBookmarkletCommand(ctx);
      }
    });
    this.registerObsidianProtocolHandler("obsidian-clipper", async (e) => {
      const parameters = e;
      const url = parameters.url;
      const title = parameters.title;
      const format2 = parameters.format;
      const notePath = parameters.notePath;
      let highlightData = parameters.highlightdata;
      if (format2 === "html") {
        highlightData = new MarkdownProcessor(parameters.highlightdata).process(this.settings.markdownSettings);
      }
      const noteEntry = new ClippedData(title, url, this.settings, this.app, highlightData);
      if (notePath && notePath !== "") {
        const file = this.app.vault.getAbstractFileByPath(notePath);
        new TopicNoteEntry(this.app, this.settings.topicOpenOnWrite, this.settings.topicPosition, this.settings.topicEntryTemplateLocation).writeToNote(file, noteEntry);
      } else {
        if (this.settings.useDailyNote) {
          new DailyPeriodicNoteEntry(this.app, this.settings.dailyOpenOnWrite, this.settings.dailyPosition, this.settings.dailyEntryTemplateLocation).writeToPeriodicNote(noteEntry, this.settings.dailyNoteHeading);
        }
        if (this.settings.useWeeklyNote) {
          new WeeklyPeriodicNoteEntry(this.app, this.settings.weeklyOpenOnWrite, this.settings.weeklyPosition, this.settings.weeklyEntryTemplateLocation).writeToPeriodicNote(noteEntry, this.settings.weeklyNoteHeading);
        }
      }
    });
  }
  async loadSettings() {
    let mergedSettings = DEFAULT_SETTINGS;
    const settingsData = await this.loadData();
    if (settingsData !== null) {
      mergedSettings = deepmerge(DEFAULT_SETTINGS, settingsData);
    }
    this.settings = mergedSettings;
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  handleSubjectBookmarkletCommand(ctx) {
    const bm = new BookmarketlGenerator(this.app.vault.getName(), ctx.file.path).generateBookmarklet();
    const bookmarkletLinkModal = new import_obsidian5.Modal(this.app);
    bookmarkletLinkModal.titleEl.createEl("h2", {
      text: "Copy Your Subject Bookmarklet"
    });
    bookmarkletLinkModal.contentEl.createEl("a", {
      href: bm,
      text: `Obsidian Clipper (${ctx.file.name})`
    });
    bookmarkletLinkModal.open();
  }
  handleCopyBookmarkletCommand() {
    const bm = new BookmarketlGenerator(this.app.vault.getName()).generateBookmarklet();
    const bookmarkletLinkModal = new import_obsidian5.Modal(this.app);
    bookmarkletLinkModal.titleEl.createEl("h2", {
      text: "Copy Your Vault Bookmarklet"
    });
    bookmarkletLinkModal.contentEl.createEl("a", {
      href: bm,
      text: `Obsidian Clipper (${this.app.vault.getName()})`
    });
    bookmarkletLinkModal.open();
  }
};
var SettingTab = class extends import_obsidian5.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    init2(this.plugin);
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    this.view = new SettingsComponent_default({
      target: containerEl,
      props: {
        app: this.app
      }
    });
  }
  async hide() {
    super.hide();
    this.view.$destroy();
  }
};
